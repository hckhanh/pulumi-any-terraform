---
applyTo: '**/*.{ts,js}'
---

# Project Context

This is a Pulumi provider collection repository that dynamically bridges Terraform providers to Pulumi TypeScript libraries. The repository contains generated TypeScript bindings for various cloud providers and infrastructure services.

## Key Principles

- **Generated Code First**: Most TypeScript files in `/packages/*/` are auto-generated from Terraform providers - DO NOT edit them directly
- **Build System Focused**: Manual changes are primarily in `/tools/` directory for Nx build orchestration
- **Type Safety**: Maintain strict TypeScript typing for all custom tools and configurations
- **Infrastructure as Code**: Focus on clear, maintainable infrastructure patterns

## Project Structure

```
├── packages/              # Auto-generated Pulumi provider packages (DO NOT EDIT)
│   ├── better-uptime/     # Example provider package
│   ├── bunnynet/          # Example provider package
│   └── ...
├── tools/                 # Manual build system plugins (EDITABLE)
│   ├── build.ts          # Build orchestration
│   ├── linter.ts         # Linting configuration
│   └── ...
├── .github/              # GitHub configuration including this file
└── nx.json               # Nx workspace configuration
```

## Before Writing Code

1. **Check if file is generated**: Look for `// *** WARNING: this file was generated by pulumi-language-nodejs. ***` header
2. **Never edit generated files**: Only modify files in `/tools/`, configuration files, and documentation
3. **Follow existing patterns**: Match the style and structure of existing build plugins
4. **Test with workspace**: Use `npx nx run-many --target=check` to validate changes

## Rules for Manual Code

### Build System & Tools

- Use Nx `CreateNodesResult` interface for build plugins in `/tools/`
- Extend the base `Plugin` class for consistent plugin structure
- Use `node:` prefix for Node.js built-in modules (e.g., `node:path`, `node:fs`)
- Define clear target metadata with `description` and `technologies` arrays
- Use dependency arrays (`dependsOn`) to establish proper build order

### TypeScript Best Practices

- Use `import type` for type-only imports
- Avoid using `any` - prefer proper typing
- Use `const` declarations for variables that are never reassigned
- Prefer arrow functions for consistency
- Use template literals over string concatenation
- Use object spread instead of `Object.assign()`

### Code Complexity and Quality

- Don't use the `arguments` object
- Don't use the comma operator
- Don't use unnecessary boolean casts
- Use for...of statements instead of Array.forEach
- Don't use unnecessary catch clauses
- Don't use unnecessary constructors
- Don't use unnecessary continue statements
- Don't export empty modules
- Don't use unnecessary labels
- Don't use unnecessary nested block statements
- Don't rename imports to the same name
- Don't use unnecessary string concatenation
- Don't use useless ternary operators when simpler alternatives exist
- Don't initialize variables to undefined
- Use arrow functions instead of function expressions
- Use literal property access instead of computed property access
- Use regular expression literals instead of the RegExp constructor when possible
- Don't use literal numbers that lose precision

### Correctness and Safety

- Don't assign a value to itself
- Don't use lexical declarations in switch clauses
- Don't write unreachable code
- Don't have unused function parameters
- Don't have unused imports
- Don't have unused variables
- Use isNaN() when checking for NaN
- Make sure typeof expressions are compared to valid values
- Don't use expressions where the operation doesn't change the value
- Make sure Promise-like statements are handled appropriately
- Don't hardcode sensitive data like API keys and tokens
- Don't let variable declarations shadow variables from outer scopes
- Don't use the TypeScript directive @ts-ignore
- Use object spread instead of `Object.assign()` when constructing new objects
- Always use the radix argument when using `parseInt()`
- Don't use the `delete` operator
- Don't use namespace imports
- Declare regex literals at the top level

### Style and Consistency

- Don't use global `eval()`
- Don't use negation in `if` statements that have `else` clauses
- Don't use nested ternary expressions
- Don't reassign function parameters
- Use `String.slice()` instead of `String.substr()` and `String.substring()`
- Don't use template literals if you don't need interpolation
- Don't use `else` blocks when the `if` block breaks early
- Don't use Array constructors
- Use consistent accessibility modifiers on class properties and methods
- Use `const` declarations for variables that are only assigned once
- Put default function parameters and optional function parameters last
- Include a `default` clause in switch statements
- Use the `**` operator instead of `Math.pow`
- Use the `node:` protocol for Node.js builtin modules
- Use assignment operator shorthand where possible
- Use template literals over string concatenation
- Use `new` when throwing an error
- Don't throw non-Error values

## Common Tasks

- `pnpm install` - Install dependencies
- `npx nx run-many --target=check` - Run quality checks across all packages
- `npx nx run-many --target=build` - Build all packages
- `npx nx run root:prettier:write` - Format all code
- `npx nx run root:syncpack:format` - Fix dependency version mismatches

## Working with Generated Code

### Understanding Pulumi Providers

Generated packages follow this pattern:

- `index.ts` - Main exports with lazy loading
- `*.ts` - Resource classes extending `pulumi.CustomResource`
- `types/` - Input/output type definitions
- `config/` - Provider configuration

### When You Need to Make Changes

1. **For build system changes**: Edit files in `/tools/`
2. **For documentation**: Edit README files
3. **For dependencies**: Update `package.json` files
4. **For generated code**: Update the source Terraform provider and regenerate

### Example: Adding New Build Plugin

```typescript
import type { CreateNodesResult } from '@nx/devkit'
import { Plugin } from './utils/plugin'
import { dirname } from 'node:path'

class MyPlugin extends Plugin {
  constructor() {
    super('**/*/my-config.json') // File pattern to match
  }

  protected processFile(file: string): CreateNodesResult {
    const projectRoot = dirname(file)

    return {
      projects: {
        [projectRoot]: {
          root: projectRoot,
          targets: {
            'my-task': {
              command: 'my-command',
              inputs: ['sources'],
              options: { cwd: '{projectRoot}' },
              metadata: {
                description: 'My custom task',
                technologies: ['node'],
              },
            },
          },
        },
      },
    }
  }
}

const plugin = new MyPlugin()
export const { createNodesV2 } = plugin
```
