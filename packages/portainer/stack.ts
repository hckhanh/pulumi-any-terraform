// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "./types/input";
import * as outputs from "./types/output";
import * as utilities from "./utilities";

export class Stack extends pulumi.CustomResource {
    /**
     * Get an existing Stack resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: StackState, opts?: pulumi.CustomResourceOptions): Stack {
        return new Stack(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'portainer:index/stack:Stack';

    /**
     * Returns true if the given object is an instance of Stack.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is Stack {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === Stack.__pulumiType;
    }

    /**
     * List of additional Compose file paths to use when deploying from Git repository.
     */
    declare public readonly additionalFiles: pulumi.Output<string[] | undefined>;
    declare public readonly composeFormat: pulumi.Output<boolean | undefined>;
    /**
     * Deployment mode: 'standalone', 'swarm', or 'kubernetes'
     */
    declare public readonly deploymentType: pulumi.Output<string>;
    declare public readonly endpointId: pulumi.Output<number>;
    declare public readonly envs: pulumi.Output<outputs.StackEnv[] | undefined>;
    declare public readonly filePathInRepository: pulumi.Output<string | undefined>;
    declare public readonly filesystemPath: pulumi.Output<string | undefined>;
    /**
     * Whether to prune unused services/networks during stack update (default: true)
     */
    declare public readonly forceUpdate: pulumi.Output<boolean | undefined>;
    declare public readonly gitRepositoryAuthentication: pulumi.Output<boolean | undefined>;
    declare public readonly manifestUrl: pulumi.Output<string | undefined>;
    /**
     * Creation method: 'string', 'file', 'repository', or 'url'
     */
    declare public readonly method: pulumi.Output<string>;
    declare public readonly name: pulumi.Output<string>;
    declare public readonly namespace: pulumi.Output<string | undefined>;
    /**
     * Whether to prune unused services/networks during stack update (default: false)
     */
    declare public readonly prune: pulumi.Output<boolean | undefined>;
    /**
     * Whether to force pull latest images during stack update (default: true)
     */
    declare public readonly pullImage: pulumi.Output<boolean | undefined>;
    declare public readonly repositoryPassword: pulumi.Output<string | undefined>;
    declare public readonly repositoryReferenceName: pulumi.Output<string | undefined>;
    declare public readonly repositoryUrl: pulumi.Output<string | undefined>;
    declare public readonly repositoryUsername: pulumi.Output<string | undefined>;
    declare public readonly stackFileContent: pulumi.Output<string | undefined>;
    declare public readonly stackFilePath: pulumi.Output<string | undefined>;
    declare public readonly stackId: pulumi.Output<string>;
    /**
     * Enable autoUpdate webhook (GitOps).
     */
    declare public readonly stackWebhook: pulumi.Output<boolean | undefined>;
    declare public readonly supportRelativePath: pulumi.Output<boolean | undefined>;
    declare public readonly swarmId: pulumi.Output<string>;
    declare public readonly tlsskipVerify: pulumi.Output<boolean>;
    declare public readonly updateInterval: pulumi.Output<string | undefined>;
    /**
     * UUID of the GitOps webhook (read-only).
     */
    declare public /*out*/ readonly webhookId: pulumi.Output<string>;
    /**
     * Full URL of the webhook trigger
     */
    declare public /*out*/ readonly webhookUrl: pulumi.Output<string>;

    /**
     * Create a Stack resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: StackArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: StackArgs | StackState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as StackState | undefined;
            resourceInputs["additionalFiles"] = state?.additionalFiles;
            resourceInputs["composeFormat"] = state?.composeFormat;
            resourceInputs["deploymentType"] = state?.deploymentType;
            resourceInputs["endpointId"] = state?.endpointId;
            resourceInputs["envs"] = state?.envs;
            resourceInputs["filePathInRepository"] = state?.filePathInRepository;
            resourceInputs["filesystemPath"] = state?.filesystemPath;
            resourceInputs["forceUpdate"] = state?.forceUpdate;
            resourceInputs["gitRepositoryAuthentication"] = state?.gitRepositoryAuthentication;
            resourceInputs["manifestUrl"] = state?.manifestUrl;
            resourceInputs["method"] = state?.method;
            resourceInputs["name"] = state?.name;
            resourceInputs["namespace"] = state?.namespace;
            resourceInputs["prune"] = state?.prune;
            resourceInputs["pullImage"] = state?.pullImage;
            resourceInputs["repositoryPassword"] = state?.repositoryPassword;
            resourceInputs["repositoryReferenceName"] = state?.repositoryReferenceName;
            resourceInputs["repositoryUrl"] = state?.repositoryUrl;
            resourceInputs["repositoryUsername"] = state?.repositoryUsername;
            resourceInputs["stackFileContent"] = state?.stackFileContent;
            resourceInputs["stackFilePath"] = state?.stackFilePath;
            resourceInputs["stackId"] = state?.stackId;
            resourceInputs["stackWebhook"] = state?.stackWebhook;
            resourceInputs["supportRelativePath"] = state?.supportRelativePath;
            resourceInputs["swarmId"] = state?.swarmId;
            resourceInputs["tlsskipVerify"] = state?.tlsskipVerify;
            resourceInputs["updateInterval"] = state?.updateInterval;
            resourceInputs["webhookId"] = state?.webhookId;
            resourceInputs["webhookUrl"] = state?.webhookUrl;
        } else {
            const args = argsOrState as StackArgs | undefined;
            if (args?.deploymentType === undefined && !opts.urn) {
                throw new Error("Missing required property 'deploymentType'");
            }
            if (args?.endpointId === undefined && !opts.urn) {
                throw new Error("Missing required property 'endpointId'");
            }
            if (args?.method === undefined && !opts.urn) {
                throw new Error("Missing required property 'method'");
            }
            resourceInputs["additionalFiles"] = args?.additionalFiles;
            resourceInputs["composeFormat"] = args?.composeFormat;
            resourceInputs["deploymentType"] = args?.deploymentType;
            resourceInputs["endpointId"] = args?.endpointId;
            resourceInputs["envs"] = args?.envs;
            resourceInputs["filePathInRepository"] = args?.filePathInRepository;
            resourceInputs["filesystemPath"] = args?.filesystemPath;
            resourceInputs["forceUpdate"] = args?.forceUpdate;
            resourceInputs["gitRepositoryAuthentication"] = args?.gitRepositoryAuthentication;
            resourceInputs["manifestUrl"] = args?.manifestUrl;
            resourceInputs["method"] = args?.method;
            resourceInputs["name"] = args?.name;
            resourceInputs["namespace"] = args?.namespace;
            resourceInputs["prune"] = args?.prune;
            resourceInputs["pullImage"] = args?.pullImage;
            resourceInputs["repositoryPassword"] = args?.repositoryPassword ? pulumi.secret(args.repositoryPassword) : undefined;
            resourceInputs["repositoryReferenceName"] = args?.repositoryReferenceName;
            resourceInputs["repositoryUrl"] = args?.repositoryUrl;
            resourceInputs["repositoryUsername"] = args?.repositoryUsername;
            resourceInputs["stackFileContent"] = args?.stackFileContent;
            resourceInputs["stackFilePath"] = args?.stackFilePath;
            resourceInputs["stackId"] = args?.stackId;
            resourceInputs["stackWebhook"] = args?.stackWebhook;
            resourceInputs["supportRelativePath"] = args?.supportRelativePath;
            resourceInputs["swarmId"] = args?.swarmId;
            resourceInputs["tlsskipVerify"] = args?.tlsskipVerify;
            resourceInputs["updateInterval"] = args?.updateInterval;
            resourceInputs["webhookId"] = undefined /*out*/;
            resourceInputs["webhookUrl"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        const secretOpts = { additionalSecretOutputs: ["repositoryPassword"] };
        opts = pulumi.mergeOptions(opts, secretOpts);
        super(Stack.__pulumiType, name, resourceInputs, opts, false /*dependency*/, utilities.getPackage());
    }
}

/**
 * Input properties used for looking up and filtering Stack resources.
 */
export interface StackState {
    /**
     * List of additional Compose file paths to use when deploying from Git repository.
     */
    additionalFiles?: pulumi.Input<pulumi.Input<string>[]>;
    composeFormat?: pulumi.Input<boolean>;
    /**
     * Deployment mode: 'standalone', 'swarm', or 'kubernetes'
     */
    deploymentType?: pulumi.Input<string>;
    endpointId?: pulumi.Input<number>;
    envs?: pulumi.Input<pulumi.Input<inputs.StackEnv>[]>;
    filePathInRepository?: pulumi.Input<string>;
    filesystemPath?: pulumi.Input<string>;
    /**
     * Whether to prune unused services/networks during stack update (default: true)
     */
    forceUpdate?: pulumi.Input<boolean>;
    gitRepositoryAuthentication?: pulumi.Input<boolean>;
    manifestUrl?: pulumi.Input<string>;
    /**
     * Creation method: 'string', 'file', 'repository', or 'url'
     */
    method?: pulumi.Input<string>;
    name?: pulumi.Input<string>;
    namespace?: pulumi.Input<string>;
    /**
     * Whether to prune unused services/networks during stack update (default: false)
     */
    prune?: pulumi.Input<boolean>;
    /**
     * Whether to force pull latest images during stack update (default: true)
     */
    pullImage?: pulumi.Input<boolean>;
    repositoryPassword?: pulumi.Input<string>;
    repositoryReferenceName?: pulumi.Input<string>;
    repositoryUrl?: pulumi.Input<string>;
    repositoryUsername?: pulumi.Input<string>;
    stackFileContent?: pulumi.Input<string>;
    stackFilePath?: pulumi.Input<string>;
    stackId?: pulumi.Input<string>;
    /**
     * Enable autoUpdate webhook (GitOps).
     */
    stackWebhook?: pulumi.Input<boolean>;
    supportRelativePath?: pulumi.Input<boolean>;
    swarmId?: pulumi.Input<string>;
    tlsskipVerify?: pulumi.Input<boolean>;
    updateInterval?: pulumi.Input<string>;
    /**
     * UUID of the GitOps webhook (read-only).
     */
    webhookId?: pulumi.Input<string>;
    /**
     * Full URL of the webhook trigger
     */
    webhookUrl?: pulumi.Input<string>;
}

/**
 * The set of arguments for constructing a Stack resource.
 */
export interface StackArgs {
    /**
     * List of additional Compose file paths to use when deploying from Git repository.
     */
    additionalFiles?: pulumi.Input<pulumi.Input<string>[]>;
    composeFormat?: pulumi.Input<boolean>;
    /**
     * Deployment mode: 'standalone', 'swarm', or 'kubernetes'
     */
    deploymentType: pulumi.Input<string>;
    endpointId: pulumi.Input<number>;
    envs?: pulumi.Input<pulumi.Input<inputs.StackEnv>[]>;
    filePathInRepository?: pulumi.Input<string>;
    filesystemPath?: pulumi.Input<string>;
    /**
     * Whether to prune unused services/networks during stack update (default: true)
     */
    forceUpdate?: pulumi.Input<boolean>;
    gitRepositoryAuthentication?: pulumi.Input<boolean>;
    manifestUrl?: pulumi.Input<string>;
    /**
     * Creation method: 'string', 'file', 'repository', or 'url'
     */
    method: pulumi.Input<string>;
    name?: pulumi.Input<string>;
    namespace?: pulumi.Input<string>;
    /**
     * Whether to prune unused services/networks during stack update (default: false)
     */
    prune?: pulumi.Input<boolean>;
    /**
     * Whether to force pull latest images during stack update (default: true)
     */
    pullImage?: pulumi.Input<boolean>;
    repositoryPassword?: pulumi.Input<string>;
    repositoryReferenceName?: pulumi.Input<string>;
    repositoryUrl?: pulumi.Input<string>;
    repositoryUsername?: pulumi.Input<string>;
    stackFileContent?: pulumi.Input<string>;
    stackFilePath?: pulumi.Input<string>;
    stackId?: pulumi.Input<string>;
    /**
     * Enable autoUpdate webhook (GitOps).
     */
    stackWebhook?: pulumi.Input<boolean>;
    supportRelativePath?: pulumi.Input<boolean>;
    swarmId?: pulumi.Input<string>;
    tlsskipVerify?: pulumi.Input<boolean>;
    updateInterval?: pulumi.Input<string>;
}
