// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface ComputeContainerAppContainer {
    /**
     * The arguments that will be added to the container entry point when starting the image.
     */
    arguments?: pulumi.Input<string>;
    /**
     * A custom startup command that will execute once the container is launched.
     */
    command?: pulumi.Input<string>;
    /**
     * Defines a public endpoint for the application.
     */
    endpoints?: pulumi.Input<pulumi.Input<inputs.ComputeContainerAppContainerEndpoint>[]>;
    /**
     * Defines an environment variable for the container
     */
    envs?: pulumi.Input<pulumi.Input<inputs.ComputeContainerAppContainerEnv>[]>;
    /**
     * The unique identifier for the container.
     */
    id?: pulumi.Input<string>;
    /**
     * The image name within the registry, without the domain prefix (i.e.: `my-app`).
     */
    imageName: pulumi.Input<string>;
    /**
     * The image namespace within the registry, without the domain prefix (i.e.: `my-org`).
     */
    imageNamespace: pulumi.Input<string>;
    /**
     * Options: `Always`, `IfNotPresent`
     */
    imagePullPolicy?: pulumi.Input<string>;
    /**
     * The image registry for the container.
     */
    imageRegistry: pulumi.Input<number>;
    /**
     * The image tag (i.e.: `2.9-alpine`).
     */
    imageTag: pulumi.Input<string>;
    /**
     * Checks that the application is actively running without issues. It the check fails, the container will be automatically restarted
     */
    livenessProbes?: pulumi.Input<pulumi.Input<inputs.ComputeContainerAppContainerLivenessProbe>[]>;
    /**
     * The name of the container.
     */
    name: pulumi.Input<string>;
    /**
     * Checks if the application is fully prepared to handle incoming requests. No requests will be routed to the application until this check is successful.
     */
    readinessProbes?: pulumi.Input<pulumi.Input<inputs.ComputeContainerAppContainerReadinessProbe>[]>;
    /**
     * Checks if the application has successfully started. No requests will be routed to the application until this check is successful.
     */
    startupProbes?: pulumi.Input<pulumi.Input<inputs.ComputeContainerAppContainerStartupProbe>[]>;
    /**
     * The working directory of the container runtime.
     */
    workingDir?: pulumi.Input<string>;
}

export interface ComputeContainerAppContainerEndpoint {
    /**
     * Configurations for CDN endpoint.
     */
    cdns?: pulumi.Input<pulumi.Input<inputs.ComputeContainerAppContainerEndpointCdn>[]>;
    /**
     * The name of the endpoint.
     */
    name: pulumi.Input<string>;
    /**
     * Endpoint port configuration.
     */
    ports?: pulumi.Input<pulumi.Input<inputs.ComputeContainerAppContainerEndpointPort>[]>;
    /**
     * Options: `Anycast`, `CDN`, `InternalIP`
     */
    type: pulumi.Input<string>;
}

export interface ComputeContainerAppContainerEndpointCdn {
    /**
     * Indicates whether the container will handle TLS termination.
     */
    originSsl?: pulumi.Input<boolean>;
    /**
     * The ID of the pullzone associated with the endpoint.
     */
    pullzoneId?: pulumi.Input<number>;
    /**
     * Indicates whether sticky sessions is enabled.
     */
    stickySessions?: pulumi.Input<pulumi.Input<inputs.ComputeContainerAppContainerEndpointCdnStickySession>[]>;
}

export interface ComputeContainerAppContainerEndpointCdnStickySession {
    /**
     * Incoming request headers used to select a pod for sticky sessions.
     */
    headers: pulumi.Input<pulumi.Input<string>[]>;
}

export interface ComputeContainerAppContainerEndpointPort {
    /**
     * The container port number.
     */
    container: pulumi.Input<number>;
    /**
     * The exposed port number.
     */
    exposed?: pulumi.Input<number>;
    /**
     * Options: `Tcp`, `Udp`
     */
    protocols?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface ComputeContainerAppContainerEnv {
    /**
     * The name of the environment variable.
     */
    name: pulumi.Input<string>;
    /**
     * The value of the environment variable.
     */
    value: pulumi.Input<string>;
}

export interface ComputeContainerAppContainerLivenessProbe {
    /**
     * The number of failed probes to consider the container unhealthy.
     */
    failureThreshold?: pulumi.Input<number>;
    /**
     * gRPC-specific configurations.
     */
    grpcs?: pulumi.Input<pulumi.Input<inputs.ComputeContainerAppContainerLivenessProbeGrpc>[]>;
    /**
     * HTTP-specific configurations.
     */
    https?: pulumi.Input<pulumi.Input<inputs.ComputeContainerAppContainerLivenessProbeHttp>[]>;
    /**
     * The amount of time in seconds after the container is started to wait before the first probe is sent.
     */
    initialDelay?: pulumi.Input<number>;
    /**
     * The amount of time in seconds between each probe.
     */
    period?: pulumi.Input<number>;
    /**
     * The port within the container the probe will connect to.
     */
    port: pulumi.Input<number>;
    /**
     * The number of successful probes to consider the container healthy.
     */
    successThreshold?: pulumi.Input<number>;
    /**
     * The amount of time in seconds the probe will wait for a response before considering it a failure.
     */
    timeout?: pulumi.Input<number>;
    /**
     * Options: `grpc`, `http`, `tcp`
     */
    type: pulumi.Input<string>;
}

export interface ComputeContainerAppContainerLivenessProbeGrpc {
    /**
     * The gRPC service name.
     */
    service: pulumi.Input<string>;
}

export interface ComputeContainerAppContainerLivenessProbeHttp {
    /**
     * The expected HTTP response status code.
     */
    expectedStatus?: pulumi.Input<number>;
    /**
     * The HTTP path to be requested.
     */
    path: pulumi.Input<string>;
}

export interface ComputeContainerAppContainerReadinessProbe {
    /**
     * The number of failed probes to consider the container unhealthy.
     */
    failureThreshold?: pulumi.Input<number>;
    /**
     * gRPC-specific configurations.
     */
    grpcs?: pulumi.Input<pulumi.Input<inputs.ComputeContainerAppContainerReadinessProbeGrpc>[]>;
    /**
     * HTTP-specific configurations.
     */
    https?: pulumi.Input<pulumi.Input<inputs.ComputeContainerAppContainerReadinessProbeHttp>[]>;
    /**
     * The amount of time in seconds after the container is started to wait before the first probe is sent.
     */
    initialDelay?: pulumi.Input<number>;
    /**
     * The amount of time in seconds between each probe.
     */
    period?: pulumi.Input<number>;
    /**
     * The port within the container the probe will connect to.
     */
    port: pulumi.Input<number>;
    /**
     * The number of successful probes to consider the container healthy.
     */
    successThreshold?: pulumi.Input<number>;
    /**
     * The amount of time in seconds the probe will wait for a response before considering it a failure.
     */
    timeout?: pulumi.Input<number>;
    /**
     * Options: `grpc`, `http`, `tcp`
     */
    type: pulumi.Input<string>;
}

export interface ComputeContainerAppContainerReadinessProbeGrpc {
    /**
     * The gRPC service name.
     */
    service: pulumi.Input<string>;
}

export interface ComputeContainerAppContainerReadinessProbeHttp {
    /**
     * The expected HTTP response status code.
     */
    expectedStatus?: pulumi.Input<number>;
    /**
     * The HTTP path to be requested.
     */
    path: pulumi.Input<string>;
}

export interface ComputeContainerAppContainerStartupProbe {
    /**
     * The number of failed probes to consider the container unhealthy.
     */
    failureThreshold?: pulumi.Input<number>;
    /**
     * gRPC-specific configurations.
     */
    grpcs?: pulumi.Input<pulumi.Input<inputs.ComputeContainerAppContainerStartupProbeGrpc>[]>;
    /**
     * HTTP-specific configurations.
     */
    https?: pulumi.Input<pulumi.Input<inputs.ComputeContainerAppContainerStartupProbeHttp>[]>;
    /**
     * The amount of time in seconds after the container is started to wait before the first probe is sent.
     */
    initialDelay?: pulumi.Input<number>;
    /**
     * The amount of time in seconds between each probe.
     */
    period?: pulumi.Input<number>;
    /**
     * The port within the container the probe will connect to.
     */
    port: pulumi.Input<number>;
    /**
     * The number of successful probes to consider the container healthy.
     */
    successThreshold?: pulumi.Input<number>;
    /**
     * The amount of time in seconds the probe will wait for a response before considering it a failure.
     */
    timeout?: pulumi.Input<number>;
    /**
     * Options: `grpc`, `http`, `tcp`
     */
    type: pulumi.Input<string>;
}

export interface ComputeContainerAppContainerStartupProbeGrpc {
    /**
     * The gRPC service name.
     */
    service: pulumi.Input<string>;
}

export interface ComputeContainerAppContainerStartupProbeHttp {
    /**
     * The expected HTTP response status code.
     */
    expectedStatus?: pulumi.Input<number>;
    /**
     * The HTTP path to be requested.
     */
    path: pulumi.Input<string>;
}

export interface PullzoneEdgeruleAction {
    parameter1: pulumi.Input<string>;
    parameter2: pulumi.Input<string>;
    parameter3: pulumi.Input<string>;
    type: pulumi.Input<string>;
}

export interface PullzoneEdgeruleTrigger {
    matchType: pulumi.Input<string>;
    parameter1: pulumi.Input<string>;
    parameter2: pulumi.Input<string>;
    patterns: pulumi.Input<pulumi.Input<string>[]>;
    type: pulumi.Input<string>;
}

export interface PullzoneOrigin {
    /**
     * Indicates whether the zone will follow origin redirects.
     */
    followRedirects?: pulumi.Input<boolean>;
    /**
     * Indicates whether the current hostname is forwarded to the origin.
     */
    forwardHostHeader?: pulumi.Input<boolean>;
    /**
     * The host header that will be sent to the origin.
     */
    hostHeader?: pulumi.Input<string>;
    /**
     * The ID of the compute script used as a middleware.
     */
    middlewareScript?: pulumi.Input<number>;
    /**
     * The ID of the linked compute script.
     */
    script?: pulumi.Input<number>;
    /**
     * The ID of the linked storage zone.
     */
    storagezone?: pulumi.Input<number>;
    /**
     * Options: `ComputeContainer`, `ComputeScript`, `DnsAccelerate`, `OriginUrl`, `StorageZone`
     */
    type: pulumi.Input<string>;
    /**
     * The origin URL from where the files are fetched.
     */
    url?: pulumi.Input<string>;
    /**
     * Indicates whether the Origin's TLS certificate should be verified.
     */
    verifySsl?: pulumi.Input<boolean>;
}

export interface PullzoneRouting {
    /**
     * The list of blocked countries with the two-letter Alpha2 ISO codes. Traffic connecting from a blocked country will be rejected on the DNS level.
     */
    blockedCountries?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Options: `all`, `eu`, `scripting`
     */
    filters?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The list of budget redirected countries with the two-letter Alpha2 ISO codes. Traffic from a redirected country will connect to the cheapest possible node in North America or Europe.
     */
    redirectedCountries?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Options: `Standard`, `Volume`
     */
    tier?: pulumi.Input<string>;
    /**
     * Options: `AF`, `ASIA`, `EU`, `SA`, `US`
     */
    zones?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface StreamVideoChapter {
    end: pulumi.Input<string>;
    start: pulumi.Input<string>;
    title: pulumi.Input<string>;
}

export interface StreamVideoMoment {
    label: pulumi.Input<string>;
    timestamp: pulumi.Input<string>;
}
