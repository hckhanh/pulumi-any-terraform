// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface ComputeContainerAppContainer {
    /**
     * The arguments that will be added to the container entry point when starting the image.
     */
    arguments?: pulumi.Input<string>;
    /**
     * A custom startup command that will execute once the container is launched.
     */
    command?: pulumi.Input<string>;
    /**
     * Defines a public endpoint for the application.
     */
    endpoints?: pulumi.Input<pulumi.Input<inputs.ComputeContainerAppContainerEndpoint>[]>;
    /**
     * Defines an environment variable for the container
     */
    envs?: pulumi.Input<pulumi.Input<inputs.ComputeContainerAppContainerEnv>[]>;
    /**
     * The unique identifier for the container.
     */
    id?: pulumi.Input<string>;
    /**
     * The image name within the registry, without the domain prefix (i.e.: `my-app`).
     */
    imageName: pulumi.Input<string>;
    /**
     * The image namespace within the registry, without the domain prefix (i.e.: `my-org`).
     */
    imageNamespace: pulumi.Input<string>;
    /**
     * Options: `Always`, `IfNotPresent`
     */
    imagePullPolicy?: pulumi.Input<string>;
    /**
     * The image registry for the container.
     */
    imageRegistry: pulumi.Input<number>;
    /**
     * The image tag (i.e.: `2.9-alpine`).
     */
    imageTag: pulumi.Input<string>;
    /**
     * Checks that the application is actively running without issues. It the check fails, the container will be automatically restarted
     */
    livenessProbes?: pulumi.Input<pulumi.Input<inputs.ComputeContainerAppContainerLivenessProbe>[]>;
    /**
     * The name of the container.
     */
    name: pulumi.Input<string>;
    /**
     * Checks if the application is fully prepared to handle incoming requests. No requests will be routed to the application until this check is successful.
     */
    readinessProbes?: pulumi.Input<pulumi.Input<inputs.ComputeContainerAppContainerReadinessProbe>[]>;
    /**
     * Checks if the application has successfully started. No requests will be routed to the application until this check is successful.
     */
    startupProbes?: pulumi.Input<pulumi.Input<inputs.ComputeContainerAppContainerStartupProbe>[]>;
    /**
     * The working directory of the container runtime.
     */
    workingDir?: pulumi.Input<string>;
}

export interface ComputeContainerAppContainerEndpoint {
    /**
     * Configurations for CDN endpoint.
     */
    cdns?: pulumi.Input<pulumi.Input<inputs.ComputeContainerAppContainerEndpointCdn>[]>;
    /**
     * The name of the endpoint.
     */
    name: pulumi.Input<string>;
    /**
     * Endpoint port configuration.
     */
    ports?: pulumi.Input<pulumi.Input<inputs.ComputeContainerAppContainerEndpointPort>[]>;
    /**
     * Options: `Anycast`, `CDN`, `InternalIP`
     */
    type: pulumi.Input<string>;
}

export interface ComputeContainerAppContainerEndpointCdn {
    /**
     * Indicates whether the container will handle TLS termination.
     */
    originSsl?: pulumi.Input<boolean>;
    /**
     * The ID of the pullzone associated with the endpoint.
     */
    pullzoneId?: pulumi.Input<number>;
    /**
     * Indicates whether sticky sessions is enabled.
     */
    stickySessions?: pulumi.Input<pulumi.Input<inputs.ComputeContainerAppContainerEndpointCdnStickySession>[]>;
}

export interface ComputeContainerAppContainerEndpointCdnStickySession {
    /**
     * Incoming request headers used to select a pod for sticky sessions.
     */
    headers: pulumi.Input<pulumi.Input<string>[]>;
}

export interface ComputeContainerAppContainerEndpointPort {
    /**
     * The container port number.
     */
    container: pulumi.Input<number>;
    /**
     * The exposed port number.
     */
    exposed?: pulumi.Input<number>;
    /**
     * Options: `Tcp`, `Udp`
     */
    protocols?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface ComputeContainerAppContainerEnv {
    /**
     * The name of the environment variable.
     */
    name: pulumi.Input<string>;
    /**
     * The value of the environment variable.
     */
    value: pulumi.Input<string>;
}

export interface ComputeContainerAppContainerLivenessProbe {
    /**
     * The number of failed probes to consider the container unhealthy.
     */
    failureThreshold?: pulumi.Input<number>;
    /**
     * gRPC-specific configurations.
     */
    grpcs?: pulumi.Input<pulumi.Input<inputs.ComputeContainerAppContainerLivenessProbeGrpc>[]>;
    /**
     * HTTP-specific configurations.
     */
    https?: pulumi.Input<pulumi.Input<inputs.ComputeContainerAppContainerLivenessProbeHttp>[]>;
    /**
     * The amount of time in seconds after the container is started to wait before the first probe is sent.
     */
    initialDelay?: pulumi.Input<number>;
    /**
     * The amount of time in seconds between each probe.
     */
    period?: pulumi.Input<number>;
    /**
     * The port within the container the probe will connect to.
     */
    port: pulumi.Input<number>;
    /**
     * The number of successful probes to consider the container healthy.
     */
    successThreshold?: pulumi.Input<number>;
    /**
     * The amount of time in seconds the probe will wait for a response before considering it a failure.
     */
    timeout?: pulumi.Input<number>;
    /**
     * Options: `grpc`, `http`, `tcp`
     */
    type: pulumi.Input<string>;
}

export interface ComputeContainerAppContainerLivenessProbeGrpc {
    /**
     * The gRPC service name.
     */
    service: pulumi.Input<string>;
}

export interface ComputeContainerAppContainerLivenessProbeHttp {
    /**
     * The expected HTTP response status code.
     */
    expectedStatus?: pulumi.Input<number>;
    /**
     * The HTTP path to be requested.
     */
    path: pulumi.Input<string>;
}

export interface ComputeContainerAppContainerReadinessProbe {
    /**
     * The number of failed probes to consider the container unhealthy.
     */
    failureThreshold?: pulumi.Input<number>;
    /**
     * gRPC-specific configurations.
     */
    grpcs?: pulumi.Input<pulumi.Input<inputs.ComputeContainerAppContainerReadinessProbeGrpc>[]>;
    /**
     * HTTP-specific configurations.
     */
    https?: pulumi.Input<pulumi.Input<inputs.ComputeContainerAppContainerReadinessProbeHttp>[]>;
    /**
     * The amount of time in seconds after the container is started to wait before the first probe is sent.
     */
    initialDelay?: pulumi.Input<number>;
    /**
     * The amount of time in seconds between each probe.
     */
    period?: pulumi.Input<number>;
    /**
     * The port within the container the probe will connect to.
     */
    port: pulumi.Input<number>;
    /**
     * The number of successful probes to consider the container healthy.
     */
    successThreshold?: pulumi.Input<number>;
    /**
     * The amount of time in seconds the probe will wait for a response before considering it a failure.
     */
    timeout?: pulumi.Input<number>;
    /**
     * Options: `grpc`, `http`, `tcp`
     */
    type: pulumi.Input<string>;
}

export interface ComputeContainerAppContainerReadinessProbeGrpc {
    /**
     * The gRPC service name.
     */
    service: pulumi.Input<string>;
}

export interface ComputeContainerAppContainerReadinessProbeHttp {
    /**
     * The expected HTTP response status code.
     */
    expectedStatus?: pulumi.Input<number>;
    /**
     * The HTTP path to be requested.
     */
    path: pulumi.Input<string>;
}

export interface ComputeContainerAppContainerStartupProbe {
    /**
     * The number of failed probes to consider the container unhealthy.
     */
    failureThreshold?: pulumi.Input<number>;
    /**
     * gRPC-specific configurations.
     */
    grpcs?: pulumi.Input<pulumi.Input<inputs.ComputeContainerAppContainerStartupProbeGrpc>[]>;
    /**
     * HTTP-specific configurations.
     */
    https?: pulumi.Input<pulumi.Input<inputs.ComputeContainerAppContainerStartupProbeHttp>[]>;
    /**
     * The amount of time in seconds after the container is started to wait before the first probe is sent.
     */
    initialDelay?: pulumi.Input<number>;
    /**
     * The amount of time in seconds between each probe.
     */
    period?: pulumi.Input<number>;
    /**
     * The port within the container the probe will connect to.
     */
    port: pulumi.Input<number>;
    /**
     * The number of successful probes to consider the container healthy.
     */
    successThreshold?: pulumi.Input<number>;
    /**
     * The amount of time in seconds the probe will wait for a response before considering it a failure.
     */
    timeout?: pulumi.Input<number>;
    /**
     * Options: `grpc`, `http`, `tcp`
     */
    type: pulumi.Input<string>;
}

export interface ComputeContainerAppContainerStartupProbeGrpc {
    /**
     * The gRPC service name.
     */
    service: pulumi.Input<string>;
}

export interface ComputeContainerAppContainerStartupProbeHttp {
    /**
     * The expected HTTP response status code.
     */
    expectedStatus?: pulumi.Input<number>;
    /**
     * The HTTP path to be requested.
     */
    path: pulumi.Input<string>;
}

export interface PullzoneEdgeruleAction {
    parameter1: pulumi.Input<string>;
    parameter2: pulumi.Input<string>;
    parameter3: pulumi.Input<string>;
    type: pulumi.Input<string>;
}

export interface PullzoneEdgeruleTrigger {
    matchType: pulumi.Input<string>;
    parameter1: pulumi.Input<string>;
    parameter2: pulumi.Input<string>;
    patterns: pulumi.Input<pulumi.Input<string>[]>;
    type: pulumi.Input<string>;
}

export interface PullzoneOrigin {
    /**
     * The ID if the compute container app.
     */
    containerAppId?: pulumi.Input<string>;
    /**
     * The ID if the compute container app endpoint.
     */
    containerEndpointId?: pulumi.Input<string>;
    /**
     * Indicates whether the zone will follow origin redirects.
     */
    followRedirects?: pulumi.Input<boolean>;
    /**
     * Indicates whether the current hostname is forwarded to the origin.
     */
    forwardHostHeader?: pulumi.Input<boolean>;
    /**
     * The host header that will be sent to the origin.
     */
    hostHeader?: pulumi.Input<string>;
    /**
     * The ID of the compute script used as a middleware.
     */
    middlewareScript?: pulumi.Input<number>;
    /**
     * The ID of the linked compute script.
     */
    script?: pulumi.Input<number>;
    /**
     * The ID of the linked storage zone.
     */
    storagezone?: pulumi.Input<number>;
    /**
     * Options: `ComputeContainer`, `ComputeScript`, `DnsAccelerate`, `OriginUrl`, `StorageZone`
     */
    type: pulumi.Input<string>;
    /**
     * The origin URL from where the files are fetched.
     */
    url?: pulumi.Input<string>;
    /**
     * Indicates whether the Origin's TLS certificate should be verified.
     */
    verifySsl?: pulumi.Input<boolean>;
}

export interface PullzoneRatelimitRuleCondition {
    /**
     * Options: `BEGINSWITH`, `CONTAINS`, `CONTAINSWORD`, `DETECTSQLI`, `DETECTXSS`, `ENDSWITH`, `EQ`, `GE`, `GT`, `LE`, `LT`, `RX`, `STREQ`, `STRMATCH`, `WITHIN`
     */
    operator: pulumi.Input<string>;
    /**
     * Options: `CMDLINE`, `COMPRESSWHITESPACE`, `CSSDECODE`, `HEXENCODE`, `HTMLENTITYDECODE`, `JSDECODE`, `LENGTH`, `LOWERCASE`, `MD5`, `NORMALISEPATH`, `NORMALISEPATHWIN`, `NORMALIZEPATH`, `NORMALIZEPATHWIN`, `REMOVECOMMENTS`, `REMOVENULLS`, `REMOVEWHITESPACE`, `REPLACECOMMENTS`, `SHA1`, `URLDECODE`, `URLDECODEUNI`, `UTF8TOUNICODE`
     */
    transformations?: pulumi.Input<pulumi.Input<string>[]>;
    value: pulumi.Input<string>;
    /**
     * Options: `ARGS`, `ARGS_COMBINED_SIZE`, `ARGS_GET`, `ARGS_GET_NAMES`, `ARGS_POST`, `ARGS_POST_NAMES`, `FILES_NAMES`, `QUERY_STRING`, `REMOTE_ADDR`, `REQUEST_BASENAME`, `REQUEST_BODY`, `REQUEST_COOKIES`, `REQUEST_COOKIES_NAMES`, `REQUEST_FILENAME`, `REQUEST_HEADERS`, `REQUEST_HEADERS_NAMES`, `REQUEST_LINE`, `REQUEST_METHOD`, `REQUEST_PROTOCOL`, `REQUEST_URI`, `REQUEST_URI_RAW`, `RESPONSE_BODY`, `RESPONSE_HEADERS`, `RESPONSE_STATUS`
     */
    variable: pulumi.Input<string>;
    variableValue?: pulumi.Input<string>;
}

export interface PullzoneRatelimitRuleLimit {
    /**
     * The interval, in seconds, to consider for to trigger the rate limit rule.
     */
    interval: pulumi.Input<number>;
    /**
     * The number of request within the interval to trigger the rate limit rule.
     */
    requests: pulumi.Input<number>;
}

export interface PullzoneRatelimitRuleResponse {
    /**
     * The interval, in seconds, that the rate limit will apply.
     */
    interval: pulumi.Input<number>;
}

export interface PullzoneRouting {
    /**
     * The list of blocked countries with the two-letter Alpha2 ISO codes. Traffic connecting from a blocked country will be rejected on the DNS level.
     */
    blockedCountries?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Options: `all`, `eu`, `scripting`
     */
    filters?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The list of budget redirected countries with the two-letter Alpha2 ISO codes. Traffic from a redirected country will connect to the cheapest possible node in North America or Europe.
     */
    redirectedCountries?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Options: `Standard`, `Volume`
     */
    tier?: pulumi.Input<string>;
    /**
     * Options: `AF`, `ASIA`, `EU`, `SA`, `US`
     */
    zones?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface PullzoneShieldAccessList {
    /**
     * Options: `Allow`, `Block`, `Challenge`, `Log`
     */
    action: pulumi.Input<string>;
    /**
     * The ID of the Access List.
     */
    id: pulumi.Input<number>;
}

export interface PullzoneShieldBotDetection {
    /**
     * Combines advanced entropy analysis and cross-session consistency.
     */
    complexFingerprinting?: pulumi.Input<boolean>;
    /**
     * Controls how assertively unusual fingerprints are treated as bots.
     */
    fingerprintAggression?: pulumi.Input<number>;
    /**
     * Adjusts how precisely browsers are checked for signs of automation.
     */
    fingerprintSensitivity?: pulumi.Input<number>;
    /**
     * Monitors IP behaviour, reputation, and rate patterns.
     */
    ipSensitivity?: pulumi.Input<number>;
    /**
     * Indicates the mode the Bot Detection engine is running. Options: `Challenge`, `Log`
     */
    mode?: pulumi.Input<string>;
    /**
     * Analyzes request headers, query structure, and protocol anomalies.
     */
    requestIntegrity?: pulumi.Input<number>;
}

export interface PullzoneShieldDdos {
    /**
     * The window of time a visitor can access your website after passing a challenge. Once the timeout expires, they'll face a new challenge.
     */
    challengeWindow?: pulumi.Input<number>;
    /**
     * Options: `Asleep`, `Extreme`, `High`, `Low`, `Medium`
     */
    level: pulumi.Input<string>;
    /**
     * Indicates the mode the engine is running. Options: `Block`, `Log`
     */
    mode?: pulumi.Input<string>;
}

export interface PullzoneShieldWaf {
    /**
     * Indicates allowed HTTP methods.
     */
    allowedHttpMethods?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Indicates allowed HTTP versions.
     */
    allowedHttpVersions?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Indicates allowed values for request Content-Type.
     */
    allowedRequestContentTypes?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Determines which severity level of rules will block requests.
     */
    blockingSensitivity?: pulumi.Input<number>;
    /**
     * Determines the action to take when the request body length exceeds your plan limit. Options: `Block`, `Ignore`, `Log`
     */
    bodyLimitRequest?: pulumi.Input<string>;
    /**
     * Determines the action to take when the response body length exceeds your plan limit. Options: `Block`, `Ignore`, `Log`
     */
    bodyLimitResponse?: pulumi.Input<string>;
    /**
     * Determines which severity level of rules will trigger a detection log.
     */
    detectionSensitivity?: pulumi.Input<number>;
    /**
     * Indicates whether the WAF (Web Application Firewall) is enabled.
     */
    enabled: pulumi.Input<boolean>;
    /**
     * Determines which severity level of rules will trigger the rules and their action.
     */
    executionSensitivity?: pulumi.Input<number>;
    /**
     * When enabled, detected WAF audit logs will contain the full list of request headers sent during the request.
     */
    logHeaders?: pulumi.Input<boolean>;
    /**
     * The list of headers excluded from the logs. They will still be used for processing WAF rules.
     */
    logHeadersExcludeds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Indicates the mode the engine is running. Options: `Block`, `Log`
     */
    mode?: pulumi.Input<string>;
    /**
     * Real-time Threat Intelligence delivers zero-day protection by instantly detecting and blocking emerging threats.
     */
    realtimeThreatIntelligence?: pulumi.Input<boolean>;
    /**
     * List of disabled WAF rules.
     */
    rulesDisableds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * List of WAF rules that will not be blocked, but will be logged when triggered.
     */
    rulesLogonlies?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface PullzoneWafRuleCondition {
    /**
     * Options: `BEGINSWITH`, `CONTAINS`, `CONTAINSWORD`, `DETECTSQLI`, `DETECTXSS`, `ENDSWITH`, `EQ`, `GE`, `GT`, `LE`, `LT`, `RX`, `STREQ`, `STRMATCH`, `WITHIN`
     */
    operator: pulumi.Input<string>;
    /**
     * Options: `CMDLINE`, `COMPRESSWHITESPACE`, `CSSDECODE`, `HEXENCODE`, `HTMLENTITYDECODE`, `JSDECODE`, `LENGTH`, `LOWERCASE`, `MD5`, `NORMALISEPATH`, `NORMALISEPATHWIN`, `NORMALIZEPATH`, `NORMALIZEPATHWIN`, `REMOVECOMMENTS`, `REMOVENULLS`, `REMOVEWHITESPACE`, `REPLACECOMMENTS`, `SHA1`, `URLDECODE`, `URLDECODEUNI`, `UTF8TOUNICODE`
     */
    transformations?: pulumi.Input<pulumi.Input<string>[]>;
    value: pulumi.Input<string>;
    /**
     * Options: `ARGS`, `ARGS_COMBINED_SIZE`, `ARGS_GET`, `ARGS_GET_NAMES`, `ARGS_POST`, `ARGS_POST_NAMES`, `FILES_NAMES`, `QUERY_STRING`, `REMOTE_ADDR`, `REQUEST_BASENAME`, `REQUEST_BODY`, `REQUEST_COOKIES`, `REQUEST_COOKIES_NAMES`, `REQUEST_FILENAME`, `REQUEST_HEADERS`, `REQUEST_HEADERS_NAMES`, `REQUEST_LINE`, `REQUEST_METHOD`, `REQUEST_PROTOCOL`, `REQUEST_URI`, `REQUEST_URI_RAW`, `RESPONSE_BODY`, `RESPONSE_HEADERS`, `RESPONSE_STATUS`
     */
    variable: pulumi.Input<string>;
    variableValue?: pulumi.Input<string>;
}

export interface PullzoneWafRuleResponse {
    /**
     * The action to take if the WAF rule is triggered. Options: `Block`, `Challenge`, `Log`
     */
    action: pulumi.Input<string>;
}

export interface StreamVideoChapter {
    end: pulumi.Input<string>;
    start: pulumi.Input<string>;
    title: pulumi.Input<string>;
}

export interface StreamVideoMoment {
    label: pulumi.Input<string>;
    timestamp: pulumi.Input<string>;
}
