// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface ComputeContainerAppContainer {
    /**
     * The arguments that will be added to the container entry point when starting the image.
     */
    arguments?: string;
    /**
     * A custom startup command that will execute once the container is launched.
     */
    command?: string;
    /**
     * Defines a public endpoint for the application.
     */
    endpoints?: outputs.ComputeContainerAppContainerEndpoint[];
    /**
     * Defines an environment variable for the container
     */
    envs?: outputs.ComputeContainerAppContainerEnv[];
    /**
     * The unique identifier for the container.
     */
    id: string;
    /**
     * The image name within the registry, without the domain prefix (i.e.: `my-app`).
     */
    imageName: string;
    /**
     * The image namespace within the registry, without the domain prefix (i.e.: `my-org`).
     */
    imageNamespace: string;
    /**
     * Options: `Always`, `IfNotPresent`
     */
    imagePullPolicy: string;
    /**
     * The image registry for the container.
     */
    imageRegistry: number;
    /**
     * The image tag (i.e.: `2.9-alpine`).
     */
    imageTag: string;
    /**
     * Checks that the application is actively running without issues. It the check fails, the container will be automatically restarted
     */
    livenessProbes?: outputs.ComputeContainerAppContainerLivenessProbe[];
    /**
     * The name of the container.
     */
    name: string;
    /**
     * Checks if the application is fully prepared to handle incoming requests. No requests will be routed to the application until this check is successful.
     */
    readinessProbes?: outputs.ComputeContainerAppContainerReadinessProbe[];
    /**
     * Checks if the application has successfully started. No requests will be routed to the application until this check is successful.
     */
    startupProbes?: outputs.ComputeContainerAppContainerStartupProbe[];
    /**
     * The working directory of the container runtime.
     */
    workingDir?: string;
}

export interface ComputeContainerAppContainerEndpoint {
    /**
     * Configurations for CDN endpoint.
     */
    cdns?: outputs.ComputeContainerAppContainerEndpointCdn[];
    /**
     * The name of the endpoint.
     */
    name: string;
    /**
     * Endpoint port configuration.
     */
    ports?: outputs.ComputeContainerAppContainerEndpointPort[];
    /**
     * Options: `Anycast`, `CDN`, `InternalIP`
     */
    type: string;
}

export interface ComputeContainerAppContainerEndpointCdn {
    /**
     * Indicates whether the container will handle TLS termination.
     */
    originSsl: boolean;
    /**
     * The ID of the pullzone associated with the endpoint.
     */
    pullzoneId: number;
    /**
     * Indicates whether sticky sessions is enabled.
     */
    stickySessions?: outputs.ComputeContainerAppContainerEndpointCdnStickySession[];
}

export interface ComputeContainerAppContainerEndpointCdnStickySession {
    /**
     * Incoming request headers used to select a pod for sticky sessions.
     */
    headers: string[];
}

export interface ComputeContainerAppContainerEndpointPort {
    /**
     * The container port number.
     */
    container: number;
    /**
     * The exposed port number.
     */
    exposed?: number;
    /**
     * Options: `Tcp`, `Udp`
     */
    protocols?: string[];
}

export interface ComputeContainerAppContainerEnv {
    /**
     * The name of the environment variable.
     */
    name: string;
    /**
     * The value of the environment variable.
     */
    value: string;
}

export interface ComputeContainerAppContainerLivenessProbe {
    /**
     * The number of failed probes to consider the container unhealthy.
     */
    failureThreshold: number;
    /**
     * gRPC-specific configurations.
     */
    grpcs?: outputs.ComputeContainerAppContainerLivenessProbeGrpc[];
    /**
     * HTTP-specific configurations.
     */
    https?: outputs.ComputeContainerAppContainerLivenessProbeHttp[];
    /**
     * The amount of time in seconds after the container is started to wait before the first probe is sent.
     */
    initialDelay: number;
    /**
     * The amount of time in seconds between each probe.
     */
    period: number;
    /**
     * The port within the container the probe will connect to.
     */
    port: number;
    /**
     * The number of successful probes to consider the container healthy.
     */
    successThreshold: number;
    /**
     * The amount of time in seconds the probe will wait for a response before considering it a failure.
     */
    timeout: number;
    /**
     * Options: <span pulumi-lang-nodejs="`grpc`" pulumi-lang-dotnet="`Grpc`" pulumi-lang-go="`grpc`" pulumi-lang-python="`grpc`" pulumi-lang-yaml="`grpc`" pulumi-lang-java="`grpc`">`grpc`</span>, <span pulumi-lang-nodejs="`http`" pulumi-lang-dotnet="`Http`" pulumi-lang-go="`http`" pulumi-lang-python="`http`" pulumi-lang-yaml="`http`" pulumi-lang-java="`http`">`http`</span>, <span pulumi-lang-nodejs="`tcp`" pulumi-lang-dotnet="`Tcp`" pulumi-lang-go="`tcp`" pulumi-lang-python="`tcp`" pulumi-lang-yaml="`tcp`" pulumi-lang-java="`tcp`">`tcp`</span>
     */
    type: string;
}

export interface ComputeContainerAppContainerLivenessProbeGrpc {
    /**
     * The gRPC service name.
     */
    service: string;
}

export interface ComputeContainerAppContainerLivenessProbeHttp {
    /**
     * The expected HTTP response status code.
     */
    expectedStatus: number;
    /**
     * The HTTP path to be requested.
     */
    path: string;
}

export interface ComputeContainerAppContainerReadinessProbe {
    /**
     * The number of failed probes to consider the container unhealthy.
     */
    failureThreshold: number;
    /**
     * gRPC-specific configurations.
     */
    grpcs?: outputs.ComputeContainerAppContainerReadinessProbeGrpc[];
    /**
     * HTTP-specific configurations.
     */
    https?: outputs.ComputeContainerAppContainerReadinessProbeHttp[];
    /**
     * The amount of time in seconds after the container is started to wait before the first probe is sent.
     */
    initialDelay: number;
    /**
     * The amount of time in seconds between each probe.
     */
    period: number;
    /**
     * The port within the container the probe will connect to.
     */
    port: number;
    /**
     * The number of successful probes to consider the container healthy.
     */
    successThreshold: number;
    /**
     * The amount of time in seconds the probe will wait for a response before considering it a failure.
     */
    timeout: number;
    /**
     * Options: <span pulumi-lang-nodejs="`grpc`" pulumi-lang-dotnet="`Grpc`" pulumi-lang-go="`grpc`" pulumi-lang-python="`grpc`" pulumi-lang-yaml="`grpc`" pulumi-lang-java="`grpc`">`grpc`</span>, <span pulumi-lang-nodejs="`http`" pulumi-lang-dotnet="`Http`" pulumi-lang-go="`http`" pulumi-lang-python="`http`" pulumi-lang-yaml="`http`" pulumi-lang-java="`http`">`http`</span>, <span pulumi-lang-nodejs="`tcp`" pulumi-lang-dotnet="`Tcp`" pulumi-lang-go="`tcp`" pulumi-lang-python="`tcp`" pulumi-lang-yaml="`tcp`" pulumi-lang-java="`tcp`">`tcp`</span>
     */
    type: string;
}

export interface ComputeContainerAppContainerReadinessProbeGrpc {
    /**
     * The gRPC service name.
     */
    service: string;
}

export interface ComputeContainerAppContainerReadinessProbeHttp {
    /**
     * The expected HTTP response status code.
     */
    expectedStatus: number;
    /**
     * The HTTP path to be requested.
     */
    path: string;
}

export interface ComputeContainerAppContainerStartupProbe {
    /**
     * The number of failed probes to consider the container unhealthy.
     */
    failureThreshold: number;
    /**
     * gRPC-specific configurations.
     */
    grpcs?: outputs.ComputeContainerAppContainerStartupProbeGrpc[];
    /**
     * HTTP-specific configurations.
     */
    https?: outputs.ComputeContainerAppContainerStartupProbeHttp[];
    /**
     * The amount of time in seconds after the container is started to wait before the first probe is sent.
     */
    initialDelay: number;
    /**
     * The amount of time in seconds between each probe.
     */
    period: number;
    /**
     * The port within the container the probe will connect to.
     */
    port: number;
    /**
     * The number of successful probes to consider the container healthy.
     */
    successThreshold: number;
    /**
     * The amount of time in seconds the probe will wait for a response before considering it a failure.
     */
    timeout: number;
    /**
     * Options: <span pulumi-lang-nodejs="`grpc`" pulumi-lang-dotnet="`Grpc`" pulumi-lang-go="`grpc`" pulumi-lang-python="`grpc`" pulumi-lang-yaml="`grpc`" pulumi-lang-java="`grpc`">`grpc`</span>, <span pulumi-lang-nodejs="`http`" pulumi-lang-dotnet="`Http`" pulumi-lang-go="`http`" pulumi-lang-python="`http`" pulumi-lang-yaml="`http`" pulumi-lang-java="`http`">`http`</span>, <span pulumi-lang-nodejs="`tcp`" pulumi-lang-dotnet="`Tcp`" pulumi-lang-go="`tcp`" pulumi-lang-python="`tcp`" pulumi-lang-yaml="`tcp`" pulumi-lang-java="`tcp`">`tcp`</span>
     */
    type: string;
}

export interface ComputeContainerAppContainerStartupProbeGrpc {
    /**
     * The gRPC service name.
     */
    service: string;
}

export interface ComputeContainerAppContainerStartupProbeHttp {
    /**
     * The expected HTTP response status code.
     */
    expectedStatus: number;
    /**
     * The HTTP path to be requested.
     */
    path: string;
}

export interface GetComputeContainerAppContainerEndpointCdn {
    originSsl: boolean;
    pullzoneId: number;
    stickySessions: outputs.GetComputeContainerAppContainerEndpointCdnStickySession[];
}

export interface GetComputeContainerAppContainerEndpointCdnStickySession {
    headers: string[];
}

export interface GetPullzoneAccessListsData {
    id: number;
    name: string;
    type: string;
}

export interface GetPullzoneOrigin {
    /**
     * The ID if the compute container app.
     */
    containerAppId: string;
    /**
     * The ID if the compute container app endpoint.
     */
    containerEndpointId: string;
    /**
     * Indicates whether the zone will follow origin redirects.
     */
    followRedirects: boolean;
    /**
     * Indicates whether the current hostname is forwarded to the origin.
     */
    forwardHostHeader: boolean;
    /**
     * The host header that will be sent to the origin.
     */
    hostHeader: string;
    /**
     * The ID of the compute script used as a middleware.
     */
    middlewareScript: number;
    /**
     * The ID of the linked compute script.
     */
    script: number;
    /**
     * The ID of the linked storage zone.
     */
    storagezone: number;
    /**
     * Options: `ComputeContainer`, `ComputeScript`, `DnsAccelerate`, `OriginUrl`, `StorageZone`
     */
    type: string;
    /**
     * The origin URL from where the files are fetched.
     */
    url: string;
    /**
     * Indicates whether the Origin's TLS certificate should be verified.
     */
    verifySsl: boolean;
}

export interface GetPullzoneRouting {
    /**
     * The list of blocked countries with the two-letter Alpha2 ISO codes. Traffic connecting from a blocked country will be rejected on the DNS level.
     */
    blockedCountries: string[];
    /**
     * Options: <span pulumi-lang-nodejs="`all`" pulumi-lang-dotnet="`All`" pulumi-lang-go="`all`" pulumi-lang-python="`all`" pulumi-lang-yaml="`all`" pulumi-lang-java="`all`">`all`</span>, <span pulumi-lang-nodejs="`eu`" pulumi-lang-dotnet="`Eu`" pulumi-lang-go="`eu`" pulumi-lang-python="`eu`" pulumi-lang-yaml="`eu`" pulumi-lang-java="`eu`">`eu`</span>, <span pulumi-lang-nodejs="`scripting`" pulumi-lang-dotnet="`Scripting`" pulumi-lang-go="`scripting`" pulumi-lang-python="`scripting`" pulumi-lang-yaml="`scripting`" pulumi-lang-java="`scripting`">`scripting`</span>
     */
    filters: string[];
    /**
     * The list of budget redirected countries with the two-letter Alpha2 ISO codes. Traffic from a redirected country will connect to the cheapest possible node in North America or Europe.
     */
    redirectedCountries: string[];
    /**
     * Options: `Standard`, `Volume`
     */
    tier: string;
    /**
     * Options: `AF`, `ASIA`, `EU`, `SA`, `US`
     */
    zones: string[];
}

export interface PullzoneEdgeruleAction {
    parameter1: string;
    parameter2: string;
    parameter3: string;
    type: string;
}

export interface PullzoneEdgeruleTrigger {
    matchType: string;
    parameter1: string;
    parameter2: string;
    patterns: string[];
    type: string;
}

export interface PullzoneOrigin {
    /**
     * The ID if the compute container app.
     */
    containerAppId: string;
    /**
     * The ID if the compute container app endpoint.
     */
    containerEndpointId: string;
    /**
     * Indicates whether the zone will follow origin redirects.
     */
    followRedirects: boolean;
    /**
     * Indicates whether the current hostname is forwarded to the origin.
     */
    forwardHostHeader: boolean;
    /**
     * The host header that will be sent to the origin.
     */
    hostHeader: string;
    /**
     * The ID of the compute script used as a middleware.
     */
    middlewareScript: number;
    /**
     * The ID of the linked compute script.
     */
    script?: number;
    /**
     * The ID of the linked storage zone.
     */
    storagezone?: number;
    /**
     * Options: `ComputeContainer`, `ComputeScript`, `DnsAccelerate`, `OriginUrl`, `StorageZone`
     */
    type: string;
    /**
     * The origin URL from where the files are fetched.
     */
    url?: string;
    /**
     * Indicates whether the Origin's TLS certificate should be verified.
     */
    verifySsl: boolean;
}

export interface PullzoneRatelimitRuleCondition {
    /**
     * Options: `BEGINSWITH`, `CONTAINS`, `CONTAINSWORD`, `DETECTSQLI`, `DETECTXSS`, `ENDSWITH`, `EQ`, `GE`, `GT`, `LE`, `LT`, `RX`, `STREQ`, `STRMATCH`, `WITHIN`
     */
    operator: string;
    /**
     * Options: `CMDLINE`, `COMPRESSWHITESPACE`, `CSSDECODE`, `HEXENCODE`, `HTMLENTITYDECODE`, `JSDECODE`, `LENGTH`, `LOWERCASE`, `MD5`, `NORMALISEPATH`, `NORMALISEPATHWIN`, `NORMALIZEPATH`, `NORMALIZEPATHWIN`, `REMOVECOMMENTS`, `REMOVENULLS`, `REMOVEWHITESPACE`, `REPLACECOMMENTS`, `SHA1`, `URLDECODE`, `URLDECODEUNI`, `UTF8TOUNICODE`
     */
    transformations?: string[];
    value: string;
    /**
     * Options: `ARGS`, `ARGS_COMBINED_SIZE`, `ARGS_GET`, `ARGS_GET_NAMES`, `ARGS_POST`, `ARGS_POST_NAMES`, `FILES_NAMES`, `QUERY_STRING`, `REMOTE_ADDR`, `REQUEST_BASENAME`, `REQUEST_BODY`, `REQUEST_COOKIES`, `REQUEST_COOKIES_NAMES`, `REQUEST_FILENAME`, `REQUEST_HEADERS`, `REQUEST_HEADERS_NAMES`, `REQUEST_LINE`, `REQUEST_METHOD`, `REQUEST_PROTOCOL`, `REQUEST_URI`, `REQUEST_URI_RAW`, `RESPONSE_BODY`, `RESPONSE_HEADERS`, `RESPONSE_STATUS`
     */
    variable: string;
    variableValue?: string;
}

export interface PullzoneRatelimitRuleLimit {
    /**
     * The interval, in seconds, to consider for to trigger the rate limit rule.
     */
    interval: number;
    /**
     * The number of request within the interval to trigger the rate limit rule.
     */
    requests: number;
}

export interface PullzoneRatelimitRuleResponse {
    /**
     * The interval, in seconds, that the rate limit will apply.
     */
    interval: number;
}

export interface PullzoneRouting {
    /**
     * The list of blocked countries with the two-letter Alpha2 ISO codes. Traffic connecting from a blocked country will be rejected on the DNS level.
     */
    blockedCountries: string[];
    /**
     * Options: <span pulumi-lang-nodejs="`all`" pulumi-lang-dotnet="`All`" pulumi-lang-go="`all`" pulumi-lang-python="`all`" pulumi-lang-yaml="`all`" pulumi-lang-java="`all`">`all`</span>, <span pulumi-lang-nodejs="`eu`" pulumi-lang-dotnet="`Eu`" pulumi-lang-go="`eu`" pulumi-lang-python="`eu`" pulumi-lang-yaml="`eu`" pulumi-lang-java="`eu`">`eu`</span>, <span pulumi-lang-nodejs="`scripting`" pulumi-lang-dotnet="`Scripting`" pulumi-lang-go="`scripting`" pulumi-lang-python="`scripting`" pulumi-lang-yaml="`scripting`" pulumi-lang-java="`scripting`">`scripting`</span>
     */
    filters: string[];
    /**
     * The list of budget redirected countries with the two-letter Alpha2 ISO codes. Traffic from a redirected country will connect to the cheapest possible node in North America or Europe.
     */
    redirectedCountries: string[];
    /**
     * Options: `Standard`, `Volume`
     */
    tier: string;
    /**
     * Options: `AF`, `ASIA`, `EU`, `SA`, `US`
     */
    zones: string[];
}

export interface PullzoneShieldAccessList {
    /**
     * Options: `Allow`, `Block`, `Challenge`, `Log`
     */
    action: string;
    /**
     * The ID of the Access List.
     */
    id: number;
}

export interface PullzoneShieldBotDetection {
    /**
     * Combines advanced entropy analysis and cross-session consistency.
     */
    complexFingerprinting: boolean;
    /**
     * Controls how assertively unusual fingerprints are treated as bots.
     */
    fingerprintAggression: number;
    /**
     * Adjusts how precisely browsers are checked for signs of automation.
     */
    fingerprintSensitivity: number;
    /**
     * Monitors IP behaviour, reputation, and rate patterns.
     */
    ipSensitivity: number;
    /**
     * Indicates the mode the Bot Detection engine is running. Options: `Challenge`, `Log`
     */
    mode: string;
    /**
     * Analyzes request headers, query structure, and protocol anomalies.
     */
    requestIntegrity: number;
}

export interface PullzoneShieldDdos {
    /**
     * The window of time a visitor can access your website after passing a challenge. Once the timeout expires, they'll face a new challenge.
     */
    challengeWindow: number;
    /**
     * Options: `Asleep`, `Extreme`, `High`, `Low`, `Medium`
     */
    level: string;
    /**
     * Indicates the mode the engine is running. Options: `Block`, `Log`
     */
    mode: string;
}

export interface PullzoneShieldWaf {
    /**
     * Indicates allowed HTTP methods.
     */
    allowedHttpMethods: string[];
    /**
     * Indicates allowed HTTP versions.
     */
    allowedHttpVersions: string[];
    /**
     * Indicates allowed values for request Content-Type.
     */
    allowedRequestContentTypes: string[];
    /**
     * Determines which severity level of rules will block requests.
     */
    blockingSensitivity: number;
    /**
     * Determines the action to take when the request body length exceeds your plan limit. Options: `Block`, `Ignore`, `Log`
     */
    bodyLimitRequest: string;
    /**
     * Determines the action to take when the response body length exceeds your plan limit. Options: `Block`, `Ignore`, `Log`
     */
    bodyLimitResponse: string;
    /**
     * Determines which severity level of rules will trigger a detection log.
     */
    detectionSensitivity: number;
    /**
     * Indicates whether the WAF (Web Application Firewall) is enabled.
     */
    enabled: boolean;
    /**
     * Determines which severity level of rules will trigger the rules and their action.
     */
    executionSensitivity: number;
    /**
     * When enabled, detected WAF audit logs will contain the full list of request headers sent during the request.
     */
    logHeaders: boolean;
    /**
     * The list of headers excluded from the logs. They will still be used for processing WAF rules.
     */
    logHeadersExcludeds: string[];
    /**
     * Indicates the mode the engine is running. Options: `Block`, `Log`
     */
    mode: string;
    /**
     * Real-time Threat Intelligence delivers zero-day protection by instantly detecting and blocking emerging threats.
     */
    realtimeThreatIntelligence: boolean;
    /**
     * List of disabled WAF rules.
     */
    rulesDisableds: string[];
    /**
     * List of WAF rules that will not be blocked, but will be logged when triggered.
     */
    rulesLogonlies: string[];
}

export interface PullzoneWafRuleCondition {
    /**
     * Options: `BEGINSWITH`, `CONTAINS`, `CONTAINSWORD`, `DETECTSQLI`, `DETECTXSS`, `ENDSWITH`, `EQ`, `GE`, `GT`, `LE`, `LT`, `RX`, `STREQ`, `STRMATCH`, `WITHIN`
     */
    operator: string;
    /**
     * Options: `CMDLINE`, `COMPRESSWHITESPACE`, `CSSDECODE`, `HEXENCODE`, `HTMLENTITYDECODE`, `JSDECODE`, `LENGTH`, `LOWERCASE`, `MD5`, `NORMALISEPATH`, `NORMALISEPATHWIN`, `NORMALIZEPATH`, `NORMALIZEPATHWIN`, `REMOVECOMMENTS`, `REMOVENULLS`, `REMOVEWHITESPACE`, `REPLACECOMMENTS`, `SHA1`, `URLDECODE`, `URLDECODEUNI`, `UTF8TOUNICODE`
     */
    transformations?: string[];
    value: string;
    /**
     * Options: `ARGS`, `ARGS_COMBINED_SIZE`, `ARGS_GET`, `ARGS_GET_NAMES`, `ARGS_POST`, `ARGS_POST_NAMES`, `FILES_NAMES`, `QUERY_STRING`, `REMOTE_ADDR`, `REQUEST_BASENAME`, `REQUEST_BODY`, `REQUEST_COOKIES`, `REQUEST_COOKIES_NAMES`, `REQUEST_FILENAME`, `REQUEST_HEADERS`, `REQUEST_HEADERS_NAMES`, `REQUEST_LINE`, `REQUEST_METHOD`, `REQUEST_PROTOCOL`, `REQUEST_URI`, `REQUEST_URI_RAW`, `RESPONSE_BODY`, `RESPONSE_HEADERS`, `RESPONSE_STATUS`
     */
    variable: string;
    variableValue?: string;
}

export interface PullzoneWafRuleResponse {
    /**
     * The action to take if the WAF rule is triggered. Options: `Block`, `Challenge`, `Log`
     */
    action: string;
}

export interface StreamVideoChapter {
    end: string;
    start: string;
    title: string;
}

export interface StreamVideoMoment {
    label: string;
    timestamp: string;
}

