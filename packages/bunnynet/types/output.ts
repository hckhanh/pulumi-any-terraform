// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface ComputeContainerAppContainer {
    /**
     * The arguments that will be added to the container entry point when starting the image.
     */
    arguments?: string;
    /**
     * A custom startup command that will execute once the container is launched.
     */
    command?: string;
    /**
     * Defines a public endpoint for the application.
     */
    endpoints?: outputs.ComputeContainerAppContainerEndpoint[];
    /**
     * Defines an environment variable for the container
     */
    envs?: outputs.ComputeContainerAppContainerEnv[];
    /**
     * The unique identifier for the container.
     */
    id: string;
    /**
     * The image name within the registry, without the domain prefix (i.e.: `my-app`).
     */
    imageName: string;
    /**
     * The image namespace within the registry, without the domain prefix (i.e.: `my-org`).
     */
    imageNamespace: string;
    /**
     * Options: `Always`, `IfNotPresent`
     */
    imagePullPolicy?: string;
    /**
     * The image registry for the container.
     */
    imageRegistry: number;
    /**
     * The image tag (i.e.: `2.9-alpine`).
     */
    imageTag: string;
    /**
     * Checks that the application is actively running without issues. It the check fails, the container will be automatically restarted
     */
    livenessProbes?: outputs.ComputeContainerAppContainerLivenessProbe[];
    /**
     * The name of the container.
     */
    name: string;
    /**
     * Checks if the application is fully prepared to handle incoming requests. No requests will be routed to the application until this check is successful.
     */
    readinessProbes?: outputs.ComputeContainerAppContainerReadinessProbe[];
    /**
     * Checks if the application has successfully started. No requests will be routed to the application until this check is successful.
     */
    startupProbes?: outputs.ComputeContainerAppContainerStartupProbe[];
    /**
     * The working directory of the container runtime.
     */
    workingDir?: string;
}

export interface ComputeContainerAppContainerEndpoint {
    /**
     * Configurations for CDN endpoint.
     */
    cdns?: outputs.ComputeContainerAppContainerEndpointCdn[];
    /**
     * The name of the endpoint.
     */
    name: string;
    /**
     * Endpoint port configuration.
     */
    ports?: outputs.ComputeContainerAppContainerEndpointPort[];
    /**
     * Options: `Anycast`, `CDN`, `InternalIP`
     */
    type: string;
}

export interface ComputeContainerAppContainerEndpointCdn {
    /**
     * Indicates whether the container will handle TLS termination.
     */
    originSsl: boolean;
    /**
     * The ID of the pullzone associated with the endpoint.
     */
    pullzoneId: number;
    /**
     * Indicates whether sticky sessions is enabled.
     */
    stickySessions?: outputs.ComputeContainerAppContainerEndpointCdnStickySession[];
}

export interface ComputeContainerAppContainerEndpointCdnStickySession {
    /**
     * Incoming request headers used to select a pod for sticky sessions.
     */
    headers: string[];
}

export interface ComputeContainerAppContainerEndpointPort {
    /**
     * The container port number.
     */
    container: number;
    /**
     * The exposed port number.
     */
    exposed?: number;
    /**
     * Options: `Tcp`, `Udp`
     */
    protocols?: string[];
}

export interface ComputeContainerAppContainerEnv {
    /**
     * The name of the environment variable.
     */
    name: string;
    /**
     * The value of the environment variable.
     */
    value: string;
}

export interface ComputeContainerAppContainerLivenessProbe {
    /**
     * The number of failed probes to consider the container unhealthy.
     */
    failureThreshold: number;
    /**
     * gRPC-specific configurations.
     */
    grpcs?: outputs.ComputeContainerAppContainerLivenessProbeGrpc[];
    /**
     * HTTP-specific configurations.
     */
    https?: outputs.ComputeContainerAppContainerLivenessProbeHttp[];
    /**
     * The amount of time in seconds after the container is started to wait before the first probe is sent.
     */
    initialDelay: number;
    /**
     * The amount of time in seconds between each probe.
     */
    period: number;
    /**
     * The port within the container the probe will connect to.
     */
    port: number;
    /**
     * The number of successful probes to consider the container healthy.
     */
    successThreshold: number;
    /**
     * The amount of time in seconds the probe will wait for a response before considering it a failure.
     */
    timeout: number;
    /**
     * Options: `grpc`, `http`, `tcp`
     */
    type: string;
}

export interface ComputeContainerAppContainerLivenessProbeGrpc {
    /**
     * The gRPC service name.
     */
    service: string;
}

export interface ComputeContainerAppContainerLivenessProbeHttp {
    /**
     * The expected HTTP response status code.
     */
    expectedStatus: number;
    /**
     * The HTTP path to be requested.
     */
    path: string;
}

export interface ComputeContainerAppContainerReadinessProbe {
    /**
     * The number of failed probes to consider the container unhealthy.
     */
    failureThreshold: number;
    /**
     * gRPC-specific configurations.
     */
    grpcs?: outputs.ComputeContainerAppContainerReadinessProbeGrpc[];
    /**
     * HTTP-specific configurations.
     */
    https?: outputs.ComputeContainerAppContainerReadinessProbeHttp[];
    /**
     * The amount of time in seconds after the container is started to wait before the first probe is sent.
     */
    initialDelay: number;
    /**
     * The amount of time in seconds between each probe.
     */
    period: number;
    /**
     * The port within the container the probe will connect to.
     */
    port: number;
    /**
     * The number of successful probes to consider the container healthy.
     */
    successThreshold: number;
    /**
     * The amount of time in seconds the probe will wait for a response before considering it a failure.
     */
    timeout: number;
    /**
     * Options: `grpc`, `http`, `tcp`
     */
    type: string;
}

export interface ComputeContainerAppContainerReadinessProbeGrpc {
    /**
     * The gRPC service name.
     */
    service: string;
}

export interface ComputeContainerAppContainerReadinessProbeHttp {
    /**
     * The expected HTTP response status code.
     */
    expectedStatus: number;
    /**
     * The HTTP path to be requested.
     */
    path: string;
}

export interface ComputeContainerAppContainerStartupProbe {
    /**
     * The number of failed probes to consider the container unhealthy.
     */
    failureThreshold: number;
    /**
     * gRPC-specific configurations.
     */
    grpcs?: outputs.ComputeContainerAppContainerStartupProbeGrpc[];
    /**
     * HTTP-specific configurations.
     */
    https?: outputs.ComputeContainerAppContainerStartupProbeHttp[];
    /**
     * The amount of time in seconds after the container is started to wait before the first probe is sent.
     */
    initialDelay: number;
    /**
     * The amount of time in seconds between each probe.
     */
    period: number;
    /**
     * The port within the container the probe will connect to.
     */
    port: number;
    /**
     * The number of successful probes to consider the container healthy.
     */
    successThreshold: number;
    /**
     * The amount of time in seconds the probe will wait for a response before considering it a failure.
     */
    timeout: number;
    /**
     * Options: `grpc`, `http`, `tcp`
     */
    type: string;
}

export interface ComputeContainerAppContainerStartupProbeGrpc {
    /**
     * The gRPC service name.
     */
    service: string;
}

export interface ComputeContainerAppContainerStartupProbeHttp {
    /**
     * The expected HTTP response status code.
     */
    expectedStatus: number;
    /**
     * The HTTP path to be requested.
     */
    path: string;
}

export interface GetComputeContainerAppContainerEndpointCdn {
    originSsl: boolean;
    pullzoneId: number;
    stickySessions: outputs.GetComputeContainerAppContainerEndpointCdnStickySession[];
}

export interface GetComputeContainerAppContainerEndpointCdnStickySession {
    headers: string[];
}

export interface PullzoneEdgeruleAction {
    parameter1: string;
    parameter2: string;
    parameter3: string;
    type: string;
}

export interface PullzoneEdgeruleTrigger {
    matchType: string;
    parameter1: string;
    parameter2: string;
    patterns: string[];
    type: string;
}

export interface PullzoneOrigin {
    /**
     * Indicates whether the zone will follow origin redirects.
     */
    followRedirects: boolean;
    /**
     * Indicates whether the current hostname is forwarded to the origin.
     */
    forwardHostHeader: boolean;
    /**
     * The host header that will be sent to the origin.
     */
    hostHeader: string;
    /**
     * The ID of the compute script used as a middleware.
     */
    middlewareScript: number;
    /**
     * The ID of the linked compute script.
     */
    script?: number;
    /**
     * The ID of the linked storage zone.
     */
    storagezone?: number;
    /**
     * Options: `ComputeContainer`, `ComputeScript`, `DnsAccelerate`, `OriginUrl`, `StorageZone`
     */
    type: string;
    /**
     * The origin URL from where the files are fetched.
     */
    url?: string;
    /**
     * Indicates whether the Origin's TLS certificate should be verified.
     */
    verifySsl: boolean;
}

export interface PullzoneRouting {
    /**
     * The list of blocked countries with the two-letter Alpha2 ISO codes. Traffic connecting from a blocked country will be rejected on the DNS level.
     */
    blockedCountries: string[];
    /**
     * Options: `all`, `eu`, `scripting`
     */
    filters: string[];
    /**
     * The list of budget redirected countries with the two-letter Alpha2 ISO codes. Traffic from a redirected country will connect to the cheapest possible node in North America or Europe.
     */
    redirectedCountries: string[];
    /**
     * Options: `Standard`, `Volume`
     */
    tier: string;
    /**
     * Options: `AF`, `ASIA`, `EU`, `SA`, `US`
     */
    zones: string[];
}

export interface StreamVideoChapter {
    end: string;
    start: string;
    title: string;
}

export interface StreamVideoMoment {
    label: string;
    timestamp: string;
}

