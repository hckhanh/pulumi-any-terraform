// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AccessApprovalPolicyApprover {
    /**
     * The ID of the approver
     */
    id?: string;
    /**
     * The type of approver. Either group or user
     */
    type: string;
    /**
     * The username of the approver. By default, this is the email
     */
    username?: string;
}

export interface AppConnectionGcpCredentials {
    /**
     * The service account email to connect with GCP. The service account ID (the part of the email before '@') must be suffixed with the first two sections of your organization ID e.g. service-account-df92581a-0fe9@my-project.iam.gserviceaccount.com. For more details, refer to the documentation here https://infisical.com/docs/integrations/app-connections/gcp#configure-service-account-for-infisical
     */
    serviceAccountEmail?: string;
}

export interface GetGroupsGroup {
    /**
     * The ID of the group
     */
    id: string;
    /**
     * The name of the group
     */
    name: string;
    /**
     * The organization ID of the group
     */
    orgId: string;
    /**
     * The role of the group in the organization
     */
    role: string;
    /**
     * The role ID of the group in the organization
     */
    roleId: string;
}

export interface GetProjectsEnvironments {
    /**
     * The ID of the environment
     */
    id: string;
    /**
     * The name of the environment
     */
    name: string;
    /**
     * The slug of the environment
     */
    slug: string;
}

export interface GetSecretFoldersFolder {
    /**
     * The ID of the folder
     */
    id: string;
    /**
     * The name of the folder
     */
    name: string;
}

export interface GetSecretsSecrets {
    /**
     * The secret comment
     */
    comment: string;
    /**
     * The secret type (shared or personal)
     */
    secretType: string;
    /**
     * The secret value
     */
    value: string;
}

export interface IdentityAwsAuthAccessTokenTrustedIp {
    ipAddress: string;
}

export interface IdentityAzureAuthAccessTokenTrustedIp {
    ipAddress: string;
}

export interface IdentityGcpAuthAccessTokenTrustedIp {
    ipAddress: string;
}

export interface IdentityKubernetesAuthAccessTokenTrustedIp {
    ipAddress: string;
}

export interface IdentityOidcAuthAccessTokenTrustedIp {
    ipAddress: string;
}

export interface IdentityUniversalAuthAccessTokenTrustedIp {
    ipAddress: string;
}

export interface IdentityUniversalAuthClientSecretTrustedIp {
    ipAddress: string;
}

export interface IntegrationAwsParameterStoreOptions {
    /**
     * Tags to attach to the AWS parameter store secrets.
     */
    awsTags?: outputs.IntegrationAwsParameterStoreOptionsAwsTag[];
    /**
     * Whether to disable deletion of existing secrets in AWS Parameter Store.
     */
    shouldDisableDelete: boolean;
}

export interface IntegrationAwsParameterStoreOptionsAwsTag {
    /**
     * The key of the tag.
     */
    key?: string;
    /**
     * The value of the tag.
     */
    value?: string;
}

export interface IntegrationAwsSecretsManagerOptions {
    /**
     * Tags to attach to the AWS Secrets Manager secrets.
     */
    awsTags?: outputs.IntegrationAwsSecretsManagerOptionsAwsTag[];
    /**
     * The sync mode for AWS tags. The supported options are `secret-metadata` and `custom`. If `secret-metadata` is selected, the metadata of the Infisical secrets are used as tags in AWS (only supported for one-to-one integrations). If `custom` is selected, then the key/value pairs in the `aws_tags` field is used.
     */
    metadataSyncMode?: string;
    /**
     * The prefix to add to the secret name in AWS Secrets Manager.
     */
    secretPrefix?: string;
}

export interface IntegrationAwsSecretsManagerOptionsAwsTag {
    /**
     * The key of the tag.
     */
    key?: string;
    /**
     * The value of the tag.
     */
    value?: string;
}

export interface IntegrationGcpSecretManagerOptions {
    /**
     * The prefix to add to the secret name in GCP Secret Manager.
     */
    secretPrefix?: string;
    /**
     * The suffix to add to the secret name in GCP Secret Manager.
     */
    secretSuffix?: string;
}

export interface ProjectGroupRole {
    /**
     * Flag to indicate the assigned role is temporary or not. When is_temporary is true fields temporary_mode, temporary_range and temporary_access_start_time is required.
     */
    isTemporary?: boolean;
    /**
     * The slug of the role
     */
    roleSlug: string;
    /**
     * ISO time for which temporary access should begin. This is in the format YYYY-MM-DDTHH:MM:SSZ e.g. 2024-09-19T12:43:13Z
     */
    temporaryAccessStartTime?: string;
    /**
     * TTL for the temporary time. Eg: 1m, 1h, 1d. Default: 1h
     */
    temporaryRange?: string;
}

export interface ProjectIdentityIdentity {
    /**
     * The auth methods for the identity
     */
    authMethods: string[];
    /**
     * The ID of the identity
     */
    id: string;
    /**
     * The name of the identity
     */
    name: string;
}

export interface ProjectIdentityRole {
    /**
     * The id of the custom role slug
     */
    customRoleId: string;
    /**
     * The ID of the project identity role.
     */
    id: string;
    /**
     * Flag to indicate the assigned role is temporary or not. When is_temporary is true fields temporary_mode, temporary_range and temporary_access_start_time is required.
     */
    isTemporary: boolean;
    /**
     * The slug of the role
     */
    roleSlug: string;
    /**
     * ISO time for which temporary access will end. Computed based on temporary_range and temporary_access_start_time
     */
    temporaryAccessEndTime: string;
    /**
     * ISO time for which temporary access should begin. The current time is used by default.
     */
    temporaryAccessStartTime: string;
    /**
     * Type of temporary access given. Types: relative. Default: relative
     */
    temporaryMode: string;
    /**
     * TTL for the temporary time. Eg: 1m, 1h, 1d. Default: 1h
     */
    temporaryRange: string;
}

export interface ProjectIdentitySpecificPrivilegePermission {
    /**
     * Describe what action an entity can take. Enum: create,edit,delete,read
     */
    actions: string[];
    /**
     * The conditions to scope permissions
     */
    conditions: outputs.ProjectIdentitySpecificPrivilegePermissionConditions;
    /**
     * Describe what action an entity can take. Enum: role,member,groups,settings,integrations,webhooks,service-tokens,environments,tags,audit-logs,ip-allowlist,workspace,secrets,secret-rollback,secret-approval,secret-rotation,identity,certificate-authorities,certificates,certificate-templates,kms,pki-alerts,pki-collections
     */
    subject: string;
}

export interface ProjectIdentitySpecificPrivilegePermissionConditions {
    /**
     * The environment slug this permission should allow.
     */
    environment: string;
    /**
     * The secret path this permission should be scoped to
     */
    secretPath?: string;
}

export interface ProjectIdentitySpecificPrivilegePermissionsV2 {
    /**
     * Describe what actions an entity can take.
     */
    actions: string[];
    /**
     * When specified, only matching conditions will be allowed to access given resource. Refer to the documentation in https://infisical.com/docs/internals/permissions#conditions for the complete list of supported properties and operators.
     */
    conditions?: string;
    /**
     * Whether rule forbids. Set this to true if permission forbids.
     */
    inverted: boolean;
    /**
     * Describe the entity the permission pertains to.
     */
    subject: string;
}

export interface ProjectRolePermission {
    /**
     * Describe what action an entity can take. Enum: create,edit,delete,read
     */
    action: string;
    /**
     * The conditions to scope permissions
     */
    conditions?: outputs.ProjectRolePermissionConditions;
    /**
     * Describe what action an entity can take. Enum: role,member,groups,settings,integrations,webhooks,service-tokens,environments,tags,audit-logs,ip-allowlist,workspace,secrets,secret-rollback,secret-approval,secret-rotation,identity,certificate-authorities,certificates,certificate-templates,kms,pki-alerts,pki-collections
     */
    subject: string;
}

export interface ProjectRolePermissionConditions {
    /**
     * The environment slug this permission should allow.
     */
    environment?: string;
    /**
     * The secret path this permission should be scoped to
     */
    secretPath?: string;
}

export interface ProjectRolePermissionsV2 {
    /**
     * Describe what actions an entity can take.
     */
    actions: string[];
    /**
     * When specified, only matching conditions will be allowed to access given resource. Refer to the documentation in https://infisical.com/docs/internals/permissions#conditions for the complete list of supported properties and operators.
     */
    conditions?: string;
    /**
     * Whether rule forbids. Set this to true if permission forbids.
     */
    inverted: boolean;
    /**
     * Describe the entity the permission pertains to.
     */
    subject: string;
}

export interface ProjectUserRole {
    /**
     * The id of the custom role slug
     */
    customRoleId: string;
    /**
     * The ID of the project user role.
     */
    id: string;
    /**
     * Flag to indicate the assigned role is temporary or not. When is_temporary is true fields temporary_mode, temporary_range and temporary_access_start_time is required.
     */
    isTemporary: boolean;
    /**
     * The slug of the role
     */
    roleSlug: string;
    /**
     * ISO time for which temporary access will end. Computed based on temporary_range and temporary_access_start_time
     */
    temporaryAccessEndTime: string;
    /**
     * ISO time for which temporary access should begin. The current time is used by default.
     */
    temporaryAccessStartTime: string;
    /**
     * Type of temporary access given. Types: relative. Default: relative
     */
    temporaryMode: string;
    /**
     * TTL for the temporary time. Eg: 1m, 1h, 1d. Default: 1h
     */
    temporaryRange: string;
}

export interface ProjectUserUser {
    /**
     * The email of the user
     */
    email: string;
    /**
     * The first name of the user
     */
    firstName: string;
    /**
     * The id of the user
     */
    id: string;
    /**
     * The last name of the user
     */
    lastName: string;
}

export interface SecretApprovalPolicyApprover {
    /**
     * The ID of the approver
     */
    id?: string;
    /**
     * The type of approver. Either group or user
     */
    type: string;
    /**
     * The username of the approver. By default, this is the email
     */
    username?: string;
}

export interface SecretSecretReminder {
    /**
     * Note for the secret rotation reminder
     */
    note?: string;
    /**
     * Frequency of secret rotation reminder in days
     */
    repeatDays: number;
}

export interface SecretSyncAwsParameterStoreDestinationConfig {
    /**
     * The AWS region of your AWS Parameter Store
     */
    awsRegion: string;
    /**
     * The path in the AWS Parameter Store where the secrets will be stored, Example: /example/path/
     */
    path: string;
}

export interface SecretSyncAwsParameterStoreSyncOptions {
    /**
     * The AWS KMS key ID to use for encryption
     */
    awsKmsKeyId?: string;
    /**
     * Specify how Infisical should resolve the initial sync to the destination. Supported options: overwrite-destination, import-prioritize-source, import-prioritize-destination
     */
    initialSyncBehavior: string;
    /**
     * Whether to sync the secret metadata as tags
     */
    syncSecretMetadataAsTags: boolean;
    /**
     * The tags to sync to the secret
     */
    tags?: outputs.SecretSyncAwsParameterStoreSyncOptionsTag[];
}

export interface SecretSyncAwsParameterStoreSyncOptionsTag {
    /**
     * The key of the tag
     */
    key: string;
    /**
     * The value of the tag
     */
    value: string;
}

export interface SecretSyncAwsSecretsManagerDestinationConfig {
    /**
     * The AWS region of your AWS Secrets Manager
     */
    awsRegion: string;
    /**
     * The name of the AWS secret to map to. This only applies when mapping_behavior is set to 'many-to-one'.
     */
    awsSecretsManagerSecretName?: string;
    /**
     * The behavior of the mapping. Can be 'many-to-one' or 'one-to-one'. Many to One: All Infisical secrets will be mapped to a single AWS secret. One to One: Each Infisical secret will be mapped to its own AWS secret.
     */
    mappingBehavior: string;
}

export interface SecretSyncAwsSecretsManagerSyncOptions {
    /**
     * The AWS KMS key ID to use for encryption
     */
    awsKmsKeyId?: string;
    /**
     * Specify how Infisical should resolve the initial sync to the destination. Supported options: overwrite-destination, import-prioritize-source, import-prioritize-destination
     */
    initialSyncBehavior: string;
    /**
     * Whether to sync the secret metadata as tags. This is only supported for the 'one-to-one' mapping behavior.
     */
    syncSecretMetadataAsTags: boolean;
    /**
     * The tags to sync to the secret
     */
    tags?: outputs.SecretSyncAwsSecretsManagerSyncOptionsTag[];
}

export interface SecretSyncAwsSecretsManagerSyncOptionsTag {
    /**
     * The key of the tag
     */
    key: string;
    /**
     * The value of the tag
     */
    value: string;
}

export interface SecretSyncAzureAppConfigurationDestinationConfig {
    /**
     * The URL of your Azure App Configuration
     */
    configurationUrl: string;
    /**
     * The label to attach to secrets created in Azure App Configuration
     */
    label: string;
}

export interface SecretSyncAzureAppConfigurationSyncOptions {
    /**
     * Specify how Infisical should resolve the initial sync to the destination. Supported options: overwrite-destination, import-prioritize-source, import-prioritize-destination
     */
    initialSyncBehavior: string;
}

export interface SecretSyncAzureKeyVaultDestinationConfig {
    /**
     * The base URL of your Azure Key Vault
     */
    vaultBaseUrl: string;
}

export interface SecretSyncAzureKeyVaultSyncOptions {
    /**
     * Specify how Infisical should resolve the initial sync to the destination. Supported options: overwrite-destination, import-prioritize-source, import-prioritize-destination
     */
    initialSyncBehavior: string;
}

export interface SecretSyncGcpSecretManagerDestinationConfig {
    /**
     * The ID of the GCP project to sync with
     */
    projectId: string;
    /**
     * The scope of the sync with GCP Secret Manager. Supported options: global
     */
    scope: string;
}

export interface SecretSyncGcpSecretManagerSyncOptions {
    /**
     * Specify how Infisical should resolve the initial sync to the destination. Supported options: overwrite-destination, import-prioritize-source, import-prioritize-destination
     */
    initialSyncBehavior: string;
}

export namespace config {
    export interface Auth {
        /**
         * The configuration values for OIDC Auth
         */
        oidc?: outputs.config.AuthOidc;
        /**
         * The authentication token for Machine Identity Token Auth. This attribute can also be set using the `INFISICAL_TOKEN` environment variable
         */
        token?: string;
        /**
         * The configuration values for Universal Auth
         */
        universal?: outputs.config.AuthUniversal;
    }

    export interface AuthOidc {
        /**
         * Machine identity ID. Used to fetch/modify secrets for a given project. This attribute can also be set using the `INFISICAL_MACHINE_IDENTITY_ID` environment variable
         */
        identityId?: string;
        /**
         * The environment variable name for the OIDC JWT token. This attribute can also be set using the `INFISICAL_OIDC_AUTH_TOKEN_KEY_NAME` environment variable. Default is `INFISICAL_AUTH_JWT`.
         */
        tokenEnvironmentVariableName?: string;
    }

    export interface AuthUniversal {
        /**
         * Machine identity client ID. Used to fetch/modify secrets for a given project. This attribute can also be set using the `INFISICAL_UNIVERSAL_AUTH_CLIENT_ID` environment variable
         */
        clientId?: string;
        /**
         * Machine identity client secret. Used to fetch/modify secrets for a given project. This attribute can also be set using the `INFISICAL_UNIVERSAL_AUTH_CLIENT_SECRET` environment variable
         */
        clientSecret?: string;
    }

}
