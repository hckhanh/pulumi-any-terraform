// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AccessApprovalPolicyApprover {
    /**
     * The ID of the approver
     */
    id?: pulumi.Input<string>;
    /**
     * The type of approver. Either group or user
     */
    type: pulumi.Input<string>;
    /**
     * The username of the approver. By default, this is the email
     */
    username?: pulumi.Input<string>;
}

export interface AppConnectionGcpCredentials {
    /**
     * The service account email to connect with GCP. The service account ID (the part of the email before '@') must be suffixed with the first two sections of your organization ID e.g. service-account-df92581a-0fe9@my-project.iam.gserviceaccount.com. For more details, refer to the documentation here https://infisical.com/docs/integrations/app-connections/gcp#configure-service-account-for-infisical
     */
    serviceAccountEmail?: pulumi.Input<string>;
}

export interface IdentityAwsAuthAccessTokenTrustedIp {
    ipAddress?: pulumi.Input<string>;
}

export interface IdentityAzureAuthAccessTokenTrustedIp {
    ipAddress?: pulumi.Input<string>;
}

export interface IdentityGcpAuthAccessTokenTrustedIp {
    ipAddress?: pulumi.Input<string>;
}

export interface IdentityKubernetesAuthAccessTokenTrustedIp {
    ipAddress?: pulumi.Input<string>;
}

export interface IdentityOidcAuthAccessTokenTrustedIp {
    ipAddress?: pulumi.Input<string>;
}

export interface IdentityUniversalAuthAccessTokenTrustedIp {
    ipAddress?: pulumi.Input<string>;
}

export interface IdentityUniversalAuthClientSecretTrustedIp {
    ipAddress?: pulumi.Input<string>;
}

export interface IntegrationAwsParameterStoreOptions {
    /**
     * Tags to attach to the AWS parameter store secrets.
     */
    awsTags?: pulumi.Input<pulumi.Input<inputs.IntegrationAwsParameterStoreOptionsAwsTag>[]>;
    /**
     * Whether to disable deletion of existing secrets in AWS Parameter Store.
     */
    shouldDisableDelete?: pulumi.Input<boolean>;
}

export interface IntegrationAwsParameterStoreOptionsAwsTag {
    /**
     * The key of the tag.
     */
    key?: pulumi.Input<string>;
    /**
     * The value of the tag.
     */
    value?: pulumi.Input<string>;
}

export interface IntegrationAwsSecretsManagerOptions {
    /**
     * Tags to attach to the AWS Secrets Manager secrets.
     */
    awsTags?: pulumi.Input<pulumi.Input<inputs.IntegrationAwsSecretsManagerOptionsAwsTag>[]>;
    /**
     * The sync mode for AWS tags. The supported options are `secret-metadata` and `custom`. If `secret-metadata` is selected, the metadata of the Infisical secrets are used as tags in AWS (only supported for one-to-one integrations). If `custom` is selected, then the key/value pairs in the `aws_tags` field is used.
     */
    metadataSyncMode?: pulumi.Input<string>;
    /**
     * The prefix to add to the secret name in AWS Secrets Manager.
     */
    secretPrefix?: pulumi.Input<string>;
}

export interface IntegrationAwsSecretsManagerOptionsAwsTag {
    /**
     * The key of the tag.
     */
    key?: pulumi.Input<string>;
    /**
     * The value of the tag.
     */
    value?: pulumi.Input<string>;
}

export interface IntegrationGcpSecretManagerOptions {
    /**
     * The prefix to add to the secret name in GCP Secret Manager.
     */
    secretPrefix?: pulumi.Input<string>;
    /**
     * The suffix to add to the secret name in GCP Secret Manager.
     */
    secretSuffix?: pulumi.Input<string>;
}

export interface ProjectGroupRole {
    /**
     * Flag to indicate the assigned role is temporary or not. When is_temporary is true fields temporary_mode, temporary_range and temporary_access_start_time is required.
     */
    isTemporary?: pulumi.Input<boolean>;
    /**
     * The slug of the role
     */
    roleSlug: pulumi.Input<string>;
    /**
     * ISO time for which temporary access should begin. This is in the format YYYY-MM-DDTHH:MM:SSZ e.g. 2024-09-19T12:43:13Z
     */
    temporaryAccessStartTime?: pulumi.Input<string>;
    /**
     * TTL for the temporary time. Eg: 1m, 1h, 1d. Default: 1h
     */
    temporaryRange?: pulumi.Input<string>;
}

export interface ProjectIdentityIdentity {
    /**
     * The auth methods for the identity
     */
    authMethods?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The ID of the identity
     */
    id?: pulumi.Input<string>;
    /**
     * The name of the identity
     */
    name?: pulumi.Input<string>;
}

export interface ProjectIdentityRole {
    /**
     * The id of the custom role slug
     */
    customRoleId?: pulumi.Input<string>;
    /**
     * The ID of the project identity role.
     */
    id?: pulumi.Input<string>;
    /**
     * Flag to indicate the assigned role is temporary or not. When is_temporary is true fields temporary_mode, temporary_range and temporary_access_start_time is required.
     */
    isTemporary?: pulumi.Input<boolean>;
    /**
     * The slug of the role
     */
    roleSlug: pulumi.Input<string>;
    /**
     * ISO time for which temporary access will end. Computed based on temporary_range and temporary_access_start_time
     */
    temporaryAccessEndTime?: pulumi.Input<string>;
    /**
     * ISO time for which temporary access should begin. The current time is used by default.
     */
    temporaryAccessStartTime?: pulumi.Input<string>;
    /**
     * Type of temporary access given. Types: relative. Default: relative
     */
    temporaryMode?: pulumi.Input<string>;
    /**
     * TTL for the temporary time. Eg: 1m, 1h, 1d. Default: 1h
     */
    temporaryRange?: pulumi.Input<string>;
}

export interface ProjectIdentitySpecificPrivilegePermission {
    /**
     * Describe what action an entity can take. Enum: create,edit,delete,read
     */
    actions: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The conditions to scope permissions
     */
    conditions: pulumi.Input<inputs.ProjectIdentitySpecificPrivilegePermissionConditions>;
    /**
     * Describe what action an entity can take. Enum: role,member,groups,settings,integrations,webhooks,service-tokens,environments,tags,audit-logs,ip-allowlist,workspace,secrets,secret-rollback,secret-approval,secret-rotation,identity,certificate-authorities,certificates,certificate-templates,kms,pki-alerts,pki-collections
     */
    subject: pulumi.Input<string>;
}

export interface ProjectIdentitySpecificPrivilegePermissionConditions {
    /**
     * The environment slug this permission should allow.
     */
    environment: pulumi.Input<string>;
    /**
     * The secret path this permission should be scoped to
     */
    secretPath?: pulumi.Input<string>;
}

export interface ProjectIdentitySpecificPrivilegePermissionsV2 {
    /**
     * Describe what actions an entity can take.
     */
    actions: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * When specified, only matching conditions will be allowed to access given resource. Refer to the documentation in https://infisical.com/docs/internals/permissions#conditions for the complete list of supported properties and operators.
     */
    conditions?: pulumi.Input<string>;
    /**
     * Whether rule forbids. Set this to true if permission forbids.
     */
    inverted?: pulumi.Input<boolean>;
    /**
     * Describe the entity the permission pertains to.
     */
    subject: pulumi.Input<string>;
}

export interface ProjectRolePermission {
    /**
     * Describe what action an entity can take. Enum: create,edit,delete,read
     */
    action: pulumi.Input<string>;
    /**
     * The conditions to scope permissions
     */
    conditions?: pulumi.Input<inputs.ProjectRolePermissionConditions>;
    /**
     * Describe what action an entity can take. Enum: role,member,groups,settings,integrations,webhooks,service-tokens,environments,tags,audit-logs,ip-allowlist,workspace,secrets,secret-rollback,secret-approval,secret-rotation,identity,certificate-authorities,certificates,certificate-templates,kms,pki-alerts,pki-collections
     */
    subject: pulumi.Input<string>;
}

export interface ProjectRolePermissionConditions {
    /**
     * The environment slug this permission should allow.
     */
    environment?: pulumi.Input<string>;
    /**
     * The secret path this permission should be scoped to
     */
    secretPath?: pulumi.Input<string>;
}

export interface ProjectRolePermissionsV2 {
    /**
     * Describe what actions an entity can take.
     */
    actions: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * When specified, only matching conditions will be allowed to access given resource. Refer to the documentation in https://infisical.com/docs/internals/permissions#conditions for the complete list of supported properties and operators.
     */
    conditions?: pulumi.Input<string>;
    /**
     * Whether rule forbids. Set this to true if permission forbids.
     */
    inverted?: pulumi.Input<boolean>;
    /**
     * Describe the entity the permission pertains to.
     */
    subject: pulumi.Input<string>;
}

export interface ProjectUserRole {
    /**
     * The id of the custom role slug
     */
    customRoleId?: pulumi.Input<string>;
    /**
     * The ID of the project user role.
     */
    id?: pulumi.Input<string>;
    /**
     * Flag to indicate the assigned role is temporary or not. When is_temporary is true fields temporary_mode, temporary_range and temporary_access_start_time is required.
     */
    isTemporary?: pulumi.Input<boolean>;
    /**
     * The slug of the role
     */
    roleSlug: pulumi.Input<string>;
    /**
     * ISO time for which temporary access will end. Computed based on temporary_range and temporary_access_start_time
     */
    temporaryAccessEndTime?: pulumi.Input<string>;
    /**
     * ISO time for which temporary access should begin. The current time is used by default.
     */
    temporaryAccessStartTime?: pulumi.Input<string>;
    /**
     * Type of temporary access given. Types: relative. Default: relative
     */
    temporaryMode?: pulumi.Input<string>;
    /**
     * TTL for the temporary time. Eg: 1m, 1h, 1d. Default: 1h
     */
    temporaryRange?: pulumi.Input<string>;
}

export interface ProjectUserUser {
    /**
     * The email of the user
     */
    email?: pulumi.Input<string>;
    /**
     * The first name of the user
     */
    firstName?: pulumi.Input<string>;
    /**
     * The id of the user
     */
    id?: pulumi.Input<string>;
    /**
     * The last name of the user
     */
    lastName?: pulumi.Input<string>;
}

export interface ProviderAuth {
    /**
     * The configuration values for OIDC Auth
     */
    oidc?: pulumi.Input<inputs.ProviderAuthOidc>;
    /**
     * The authentication token for Machine Identity Token Auth. This attribute can also be set using the `INFISICAL_TOKEN` environment variable
     */
    token?: pulumi.Input<string>;
    /**
     * The configuration values for Universal Auth
     */
    universal?: pulumi.Input<inputs.ProviderAuthUniversal>;
}

export interface ProviderAuthOidc {
    /**
     * Machine identity ID. Used to fetch/modify secrets for a given project. This attribute can also be set using the `INFISICAL_MACHINE_IDENTITY_ID` environment variable
     */
    identityId?: pulumi.Input<string>;
    /**
     * The environment variable name for the OIDC JWT token. This attribute can also be set using the `INFISICAL_OIDC_AUTH_TOKEN_KEY_NAME` environment variable. Default is `INFISICAL_AUTH_JWT`.
     */
    tokenEnvironmentVariableName?: pulumi.Input<string>;
}

export interface ProviderAuthUniversal {
    /**
     * Machine identity client ID. Used to fetch/modify secrets for a given project. This attribute can also be set using the `INFISICAL_UNIVERSAL_AUTH_CLIENT_ID` environment variable
     */
    clientId?: pulumi.Input<string>;
    /**
     * Machine identity client secret. Used to fetch/modify secrets for a given project. This attribute can also be set using the `INFISICAL_UNIVERSAL_AUTH_CLIENT_SECRET` environment variable
     */
    clientSecret?: pulumi.Input<string>;
}

export interface SecretApprovalPolicyApprover {
    /**
     * The ID of the approver
     */
    id?: pulumi.Input<string>;
    /**
     * The type of approver. Either group or user
     */
    type: pulumi.Input<string>;
    /**
     * The username of the approver. By default, this is the email
     */
    username?: pulumi.Input<string>;
}

export interface SecretSecretReminder {
    /**
     * Note for the secret rotation reminder
     */
    note?: pulumi.Input<string>;
    /**
     * Frequency of secret rotation reminder in days
     */
    repeatDays: pulumi.Input<number>;
}

export interface SecretSyncAwsParameterStoreDestinationConfig {
    /**
     * The AWS region of your AWS Parameter Store
     */
    awsRegion: pulumi.Input<string>;
    /**
     * The path in the AWS Parameter Store where the secrets will be stored, Example: /example/path/
     */
    path: pulumi.Input<string>;
}

export interface SecretSyncAwsParameterStoreSyncOptions {
    /**
     * The AWS KMS key ID to use for encryption
     */
    awsKmsKeyId?: pulumi.Input<string>;
    /**
     * Specify how Infisical should resolve the initial sync to the destination. Supported options: overwrite-destination, import-prioritize-source, import-prioritize-destination
     */
    initialSyncBehavior: pulumi.Input<string>;
    /**
     * Whether to sync the secret metadata as tags
     */
    syncSecretMetadataAsTags?: pulumi.Input<boolean>;
    /**
     * The tags to sync to the secret
     */
    tags?: pulumi.Input<pulumi.Input<inputs.SecretSyncAwsParameterStoreSyncOptionsTag>[]>;
}

export interface SecretSyncAwsParameterStoreSyncOptionsTag {
    /**
     * The key of the tag
     */
    key: pulumi.Input<string>;
    /**
     * The value of the tag
     */
    value: pulumi.Input<string>;
}

export interface SecretSyncAwsSecretsManagerDestinationConfig {
    /**
     * The AWS region of your AWS Secrets Manager
     */
    awsRegion: pulumi.Input<string>;
    /**
     * The name of the AWS secret to map to. This only applies when mapping_behavior is set to 'many-to-one'.
     */
    awsSecretsManagerSecretName?: pulumi.Input<string>;
    /**
     * The behavior of the mapping. Can be 'many-to-one' or 'one-to-one'. Many to One: All Infisical secrets will be mapped to a single AWS secret. One to One: Each Infisical secret will be mapped to its own AWS secret.
     */
    mappingBehavior?: pulumi.Input<string>;
}

export interface SecretSyncAwsSecretsManagerSyncOptions {
    /**
     * The AWS KMS key ID to use for encryption
     */
    awsKmsKeyId?: pulumi.Input<string>;
    /**
     * Specify how Infisical should resolve the initial sync to the destination. Supported options: overwrite-destination, import-prioritize-source, import-prioritize-destination
     */
    initialSyncBehavior: pulumi.Input<string>;
    /**
     * Whether to sync the secret metadata as tags. This is only supported for the 'one-to-one' mapping behavior.
     */
    syncSecretMetadataAsTags?: pulumi.Input<boolean>;
    /**
     * The tags to sync to the secret
     */
    tags?: pulumi.Input<pulumi.Input<inputs.SecretSyncAwsSecretsManagerSyncOptionsTag>[]>;
}

export interface SecretSyncAwsSecretsManagerSyncOptionsTag {
    /**
     * The key of the tag
     */
    key: pulumi.Input<string>;
    /**
     * The value of the tag
     */
    value: pulumi.Input<string>;
}

export interface SecretSyncAzureAppConfigurationDestinationConfig {
    /**
     * The URL of your Azure App Configuration
     */
    configurationUrl: pulumi.Input<string>;
    /**
     * The label to attach to secrets created in Azure App Configuration
     */
    label?: pulumi.Input<string>;
}

export interface SecretSyncAzureAppConfigurationSyncOptions {
    /**
     * Specify how Infisical should resolve the initial sync to the destination. Supported options: overwrite-destination, import-prioritize-source, import-prioritize-destination
     */
    initialSyncBehavior: pulumi.Input<string>;
}

export interface SecretSyncAzureKeyVaultDestinationConfig {
    /**
     * The base URL of your Azure Key Vault
     */
    vaultBaseUrl: pulumi.Input<string>;
}

export interface SecretSyncAzureKeyVaultSyncOptions {
    /**
     * Specify how Infisical should resolve the initial sync to the destination. Supported options: overwrite-destination, import-prioritize-source, import-prioritize-destination
     */
    initialSyncBehavior: pulumi.Input<string>;
}

export interface SecretSyncGcpSecretManagerDestinationConfig {
    /**
     * The ID of the GCP project to sync with
     */
    projectId: pulumi.Input<string>;
    /**
     * The scope of the sync with GCP Secret Manager. Supported options: global
     */
    scope?: pulumi.Input<string>;
}

export interface SecretSyncGcpSecretManagerSyncOptions {
    /**
     * Specify how Infisical should resolve the initial sync to the destination. Supported options: overwrite-destination, import-prioritize-source, import-prioritize-destination
     */
    initialSyncBehavior: pulumi.Input<string>;
}
export namespace config {
}
