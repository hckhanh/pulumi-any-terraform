// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as utilities from "./utilities";

export class Monitor extends pulumi.CustomResource {
    /**
     * Get an existing Monitor resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state Any extra arguments used during the lookup.
     * @param opts Optional settings to control the behavior of the CustomResource.
     */
    public static get(name: string, id: pulumi.Input<pulumi.ID>, state?: MonitorState, opts?: pulumi.CustomResourceOptions): Monitor {
        return new Monitor(name, <any>state, { ...opts, id: id });
    }

    /** @internal */
    public static readonly __pulumiType = 'better-uptime:index/monitor:Monitor';

    /**
     * Returns true if the given object is an instance of Monitor.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is Monitor {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === Monitor.__pulumiType;
    }

    /**
     * Basic HTTP authentication password to include with the request.
     */
    declare public readonly authPassword: pulumi.Output<string>;
    /**
     * Basic HTTP authentication username to include with the request.
     */
    declare public readonly authUsername: pulumi.Output<string>;
    /**
     * Whether to call when a new incident is created.
     */
    declare public readonly call: pulumi.Output<boolean>;
    /**
     * How often should we check your website? In seconds.
     */
    declare public readonly checkFrequency: pulumi.Output<number>;
    /**
     * How long should we wait after observing a failure before we start a new incident? In seconds.
     */
    declare public readonly confirmationPeriod: pulumi.Output<number>;
    /**
     * The time when this monitor was created.
     */
    declare public /*out*/ readonly createdAt: pulumi.Output<string>;
    /**
     * Whether to send a critical push notification that ignores the mute switch and Do not Disturb mode when a new incident is created.
     */
    declare public readonly criticalAlert: pulumi.Output<boolean>;
    /**
     * How many days before the domain expires do you want to be alerted? Valid values are 1, 2, 3, 7, 14, 30, and 60. Set to -1 to disable domain expiration check.
     */
    declare public readonly domainExpiration: pulumi.Output<number>;
    /**
     * Whether to send an email when a new incident is created.
     */
    declare public readonly email: pulumi.Output<boolean>;
    /**
     * For Playwright monitors, the environment variables that can be used in the scenario. Example: `{ "PASSWORD" = "passw0rd" }`.
     */
    declare public readonly environmentVariables: pulumi.Output<{[key: string]: string}>;
    /**
     * Required if monitor_type is set to expected_status_code. We will create a new incident if the status code returned from the server is not in the list of expected status codes.
     */
    declare public readonly expectedStatusCodes: pulumi.Output<number[]>;
    /**
     * Set the expiration escalation policy for the monitor. It is used for SSL certificate and domain expiration checks. When set to null, an e-mail is sent to the entire team.
     */
    declare public readonly expirationPolicyId: pulumi.Output<number | undefined>;
    /**
     * Set to true for the monitor to follow redirects.
     */
    declare public readonly followRedirects: pulumi.Output<boolean>;
    /**
     * HTTP Method used to make a request. Valid options: GET, HEAD, POST, PUT, PATCH
     */
    declare public readonly httpMethod: pulumi.Output<string>;
    /**
     * Valid values:
     *
     *     `ipv4` Use IPv4 only,
     *
     *     `ipv6` Use IPv6 only.
     */
    declare public readonly ipVersion: pulumi.Output<string>;
    /**
     * When the website was last checked.
     */
    declare public /*out*/ readonly lastCheckedAt: pulumi.Output<string>;
    /**
     * An array of maintenance days to set. If a maintenance window is overnight both affected days should be set. Allowed values are ["mon", "tue", "wed", "thu", "fri", "sat", "sun"] or any subset of these days.
     */
    declare public readonly maintenanceDays: pulumi.Output<string[]>;
    /**
     * Start of the maintenance window each day. We won't check your website during this window. Example: "01:00:00"
     */
    declare public readonly maintenanceFrom: pulumi.Output<string>;
    /**
     * The timezone to use for the maintenance window each day. Defaults to UTC. The accepted values can be found in the Rails TimeZone documentation. https://api.rubyonrails.org/classes/ActiveSupport/TimeZone.html
     */
    declare public readonly maintenanceTimezone: pulumi.Output<string>;
    /**
     * End of the maintenance window each day. Example: "03:00:00"
     */
    declare public readonly maintenanceTo: pulumi.Output<string>;
    /**
     * Set this attribute if you want to add this monitor to a monitor group.
     */
    declare public readonly monitorGroupId: pulumi.Output<number>;
    /**
     * Valid values:
     *
     *     `status` We will check your website for 2XX HTTP status code.
     *
     * 	`expected_status_code` We will check if your website returned one of the values in expected_status_codes.
     *
     *     `keyword` We will check if your website contains the required_keyword.
     *
     *     `keyword_absence` We will check if your website doesn't contain the required_keyword.
     *
     *     `ping` We will ping your host specified in the url parameter.
     *
     *     `tcp` We will test a TCP port at your host specified in the url parameter
     * (port is required).
     *
     *     `udp` We will test a UDP port at your host specified in the url parameter
     * (port and required_keyword are required).
     *
     *     `smtp` We will check for a SMTP server at the host specified in the url parameter
     * (port is required, and can be one of 25, 465, 587, or a combination of those ports separated by comma).
     *
     *     `pop` We will check for a POP3 server at the host specified in the url parameter
     * (port is required, and can be 110, 995, or both).
     *
     *     `imap` We will check for an IMAP server at the host specified in the url parameter
     * (port is required, and can be 143, 993, or both).
     *
     *     `dns` We will check for a DNS server at the host specified in the url parameter
     * (request_body is required, and should contain the domain to query the DNS server with).
     *
     *     `playwright` We will run the scenario defined by playwright_script, identified in the UI by scenario_name
     */
    declare public readonly monitorType: pulumi.Output<string>;
    /**
     * Set to true to pause monitoring - we won't notify you about downtime. Set to false to resume monitoring.
     */
    declare public readonly paused: pulumi.Output<boolean>;
    /**
     * The time when this monitor was paused.
     */
    declare public /*out*/ readonly pausedAt: pulumi.Output<string>;
    /**
     * For Playwright monitors, the JavaScript source code of the scenario.
     */
    declare public readonly playwrightScript: pulumi.Output<string>;
    /**
     * Set the escalation policy for the monitor.
     */
    declare public readonly policyId: pulumi.Output<string>;
    /**
     * Required if monitor_type is set to tcp, udp, smtp, pop, or imap. tcp and udp monitors accept any ports, while smtp, pop, and imap accept only the specified ports corresponding with their servers (e.g. "25,465,587" for smtp).
     */
    declare public readonly port: pulumi.Output<string>;
    /**
     * Pronounceable name of the monitor. We will use this when we call you. Try to make it tongue-friendly, please?
     */
    declare public readonly pronounceableName: pulumi.Output<string>;
    /**
     * Whether to send a push notification when a new incident is created.
     */
    declare public readonly push: pulumi.Output<boolean>;
    /**
     * How long the monitor must be up to automatically mark an incident as resolved after being down. In seconds.
     */
    declare public readonly recoveryPeriod: pulumi.Output<number>;
    /**
     * An array of regions to set. Allowed values are ["us", "eu", "as", "au"] or any subset of these regions.
     */
    declare public readonly regions: pulumi.Output<string[]>;
    /**
     * Set to true to keep cookies when redirecting.
     */
    declare public readonly rememberCookies: pulumi.Output<boolean>;
    /**
     * Request body for POST, PUT, PATCH requests. Required if monitor_type is set to dns (domain to query the DNS server with).
     */
    declare public readonly requestBody: pulumi.Output<string>;
    /**
     * An array of request headers, consisting of name and value pairs
     */
    declare public readonly requestHeaders: pulumi.Output<{[key: string]: string}[]>;
    /**
     * How long to wait before timing out the request?
     *   - For Server and Port monitors (types `ping`, `tcp`, `udp`, `smtp`, `pop`, `imap` and `dns`) the timeout is specified in *milliseconds*. Valid options: 500, 1000, 2000, 3000, 5000.
     *   - For Playwright monitors (type `playwright`), this determines the Playwright scenario timeout instead in *seconds*. Valid options: 15, 30, 45, 60.
     *   - For all other monitors, the timeout is specified in *seconds*. Valid options: 2, 3, 5, 10, 15, 30, 45, 60.
     */
    declare public readonly requestTimeout: pulumi.Output<number>;
    /**
     * Required if monitor_type is set to keyword  or udp. We will create a new incident if this keyword is missing on your page.
     */
    declare public readonly requiredKeyword: pulumi.Output<string>;
    /**
     * For Playwright monitors, the scenario name identifying the monitor in the UI. For Playwright monitors, either `url` or `scenario_name` must be provided.
     */
    declare public readonly scenarioName: pulumi.Output<string | undefined>;
    /**
     * Whether to send an SMS when a new incident is created.
     */
    declare public readonly sms: pulumi.Output<boolean>;
    /**
     * How many days before the SSL certificate expires do you want to be alerted? Valid values are 1, 2, 3, 7, 14, 30, and 60. Set to -1 to disable SSL expiration check.
     */
    declare public readonly sslExpiration: pulumi.Output<number>;
    /**
     * The status of this website check.
     */
    declare public /*out*/ readonly status: pulumi.Output<string>;
    /**
     * Used to specify the team the resource should be created in when using global tokens.
     */
    declare public readonly teamName: pulumi.Output<string | undefined>;
    /**
     * How long to wait before escalating the incident alert to the team. Leave blank to disable escalating to the entire team. In seconds.
     */
    declare public readonly teamWait: pulumi.Output<number>;
    /**
     * The time when this monitor was updated.
     */
    declare public /*out*/ readonly updatedAt: pulumi.Output<string>;
    /**
     * URL of your website or the host you want to ping (see monitor_type below). Required for all monitor types except Playwright. For Playwright monitors, either `url` or `scenario_name` must be provided.
     */
    declare public readonly url: pulumi.Output<string | undefined>;
    /**
     * Should we verify SSL certificate validity?
     */
    declare public readonly verifySsl: pulumi.Output<boolean>;

    /**
     * Create a Monitor resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: MonitorArgs, opts?: pulumi.CustomResourceOptions)
    constructor(name: string, argsOrState?: MonitorArgs | MonitorState, opts?: pulumi.CustomResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (opts.id) {
            const state = argsOrState as MonitorState | undefined;
            resourceInputs["authPassword"] = state?.authPassword;
            resourceInputs["authUsername"] = state?.authUsername;
            resourceInputs["call"] = state?.call;
            resourceInputs["checkFrequency"] = state?.checkFrequency;
            resourceInputs["confirmationPeriod"] = state?.confirmationPeriod;
            resourceInputs["createdAt"] = state?.createdAt;
            resourceInputs["criticalAlert"] = state?.criticalAlert;
            resourceInputs["domainExpiration"] = state?.domainExpiration;
            resourceInputs["email"] = state?.email;
            resourceInputs["environmentVariables"] = state?.environmentVariables;
            resourceInputs["expectedStatusCodes"] = state?.expectedStatusCodes;
            resourceInputs["expirationPolicyId"] = state?.expirationPolicyId;
            resourceInputs["followRedirects"] = state?.followRedirects;
            resourceInputs["httpMethod"] = state?.httpMethod;
            resourceInputs["ipVersion"] = state?.ipVersion;
            resourceInputs["lastCheckedAt"] = state?.lastCheckedAt;
            resourceInputs["maintenanceDays"] = state?.maintenanceDays;
            resourceInputs["maintenanceFrom"] = state?.maintenanceFrom;
            resourceInputs["maintenanceTimezone"] = state?.maintenanceTimezone;
            resourceInputs["maintenanceTo"] = state?.maintenanceTo;
            resourceInputs["monitorGroupId"] = state?.monitorGroupId;
            resourceInputs["monitorType"] = state?.monitorType;
            resourceInputs["paused"] = state?.paused;
            resourceInputs["pausedAt"] = state?.pausedAt;
            resourceInputs["playwrightScript"] = state?.playwrightScript;
            resourceInputs["policyId"] = state?.policyId;
            resourceInputs["port"] = state?.port;
            resourceInputs["pronounceableName"] = state?.pronounceableName;
            resourceInputs["push"] = state?.push;
            resourceInputs["recoveryPeriod"] = state?.recoveryPeriod;
            resourceInputs["regions"] = state?.regions;
            resourceInputs["rememberCookies"] = state?.rememberCookies;
            resourceInputs["requestBody"] = state?.requestBody;
            resourceInputs["requestHeaders"] = state?.requestHeaders;
            resourceInputs["requestTimeout"] = state?.requestTimeout;
            resourceInputs["requiredKeyword"] = state?.requiredKeyword;
            resourceInputs["scenarioName"] = state?.scenarioName;
            resourceInputs["sms"] = state?.sms;
            resourceInputs["sslExpiration"] = state?.sslExpiration;
            resourceInputs["status"] = state?.status;
            resourceInputs["teamName"] = state?.teamName;
            resourceInputs["teamWait"] = state?.teamWait;
            resourceInputs["updatedAt"] = state?.updatedAt;
            resourceInputs["url"] = state?.url;
            resourceInputs["verifySsl"] = state?.verifySsl;
        } else {
            const args = argsOrState as MonitorArgs | undefined;
            if (args?.monitorType === undefined && !opts.urn) {
                throw new Error("Missing required property 'monitorType'");
            }
            resourceInputs["authPassword"] = args?.authPassword ? pulumi.secret(args.authPassword) : undefined;
            resourceInputs["authUsername"] = args?.authUsername ? pulumi.secret(args.authUsername) : undefined;
            resourceInputs["call"] = args?.call;
            resourceInputs["checkFrequency"] = args?.checkFrequency;
            resourceInputs["confirmationPeriod"] = args?.confirmationPeriod;
            resourceInputs["criticalAlert"] = args?.criticalAlert;
            resourceInputs["domainExpiration"] = args?.domainExpiration;
            resourceInputs["email"] = args?.email;
            resourceInputs["environmentVariables"] = args?.environmentVariables ? pulumi.secret(args.environmentVariables) : undefined;
            resourceInputs["expectedStatusCodes"] = args?.expectedStatusCodes;
            resourceInputs["expirationPolicyId"] = args?.expirationPolicyId;
            resourceInputs["followRedirects"] = args?.followRedirects;
            resourceInputs["httpMethod"] = args?.httpMethod;
            resourceInputs["ipVersion"] = args?.ipVersion;
            resourceInputs["maintenanceDays"] = args?.maintenanceDays;
            resourceInputs["maintenanceFrom"] = args?.maintenanceFrom;
            resourceInputs["maintenanceTimezone"] = args?.maintenanceTimezone;
            resourceInputs["maintenanceTo"] = args?.maintenanceTo;
            resourceInputs["monitorGroupId"] = args?.monitorGroupId;
            resourceInputs["monitorType"] = args?.monitorType;
            resourceInputs["paused"] = args?.paused;
            resourceInputs["playwrightScript"] = args?.playwrightScript;
            resourceInputs["policyId"] = args?.policyId;
            resourceInputs["port"] = args?.port;
            resourceInputs["pronounceableName"] = args?.pronounceableName;
            resourceInputs["push"] = args?.push;
            resourceInputs["recoveryPeriod"] = args?.recoveryPeriod;
            resourceInputs["regions"] = args?.regions;
            resourceInputs["rememberCookies"] = args?.rememberCookies;
            resourceInputs["requestBody"] = args?.requestBody;
            resourceInputs["requestHeaders"] = args?.requestHeaders;
            resourceInputs["requestTimeout"] = args?.requestTimeout;
            resourceInputs["requiredKeyword"] = args?.requiredKeyword;
            resourceInputs["scenarioName"] = args?.scenarioName;
            resourceInputs["sms"] = args?.sms;
            resourceInputs["sslExpiration"] = args?.sslExpiration;
            resourceInputs["teamName"] = args?.teamName;
            resourceInputs["teamWait"] = args?.teamWait;
            resourceInputs["url"] = args?.url;
            resourceInputs["verifySsl"] = args?.verifySsl;
            resourceInputs["createdAt"] = undefined /*out*/;
            resourceInputs["lastCheckedAt"] = undefined /*out*/;
            resourceInputs["pausedAt"] = undefined /*out*/;
            resourceInputs["status"] = undefined /*out*/;
            resourceInputs["updatedAt"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        const secretOpts = { additionalSecretOutputs: ["authPassword", "authUsername", "environmentVariables"] };
        opts = pulumi.mergeOptions(opts, secretOpts);
        super(Monitor.__pulumiType, name, resourceInputs, opts, false /*dependency*/, utilities.getPackage());
    }
}

/**
 * Input properties used for looking up and filtering Monitor resources.
 */
export interface MonitorState {
    /**
     * Basic HTTP authentication password to include with the request.
     */
    authPassword?: pulumi.Input<string>;
    /**
     * Basic HTTP authentication username to include with the request.
     */
    authUsername?: pulumi.Input<string>;
    /**
     * Whether to call when a new incident is created.
     */
    call?: pulumi.Input<boolean>;
    /**
     * How often should we check your website? In seconds.
     */
    checkFrequency?: pulumi.Input<number>;
    /**
     * How long should we wait after observing a failure before we start a new incident? In seconds.
     */
    confirmationPeriod?: pulumi.Input<number>;
    /**
     * The time when this monitor was created.
     */
    createdAt?: pulumi.Input<string>;
    /**
     * Whether to send a critical push notification that ignores the mute switch and Do not Disturb mode when a new incident is created.
     */
    criticalAlert?: pulumi.Input<boolean>;
    /**
     * How many days before the domain expires do you want to be alerted? Valid values are 1, 2, 3, 7, 14, 30, and 60. Set to -1 to disable domain expiration check.
     */
    domainExpiration?: pulumi.Input<number>;
    /**
     * Whether to send an email when a new incident is created.
     */
    email?: pulumi.Input<boolean>;
    /**
     * For Playwright monitors, the environment variables that can be used in the scenario. Example: `{ "PASSWORD" = "passw0rd" }`.
     */
    environmentVariables?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * Required if monitor_type is set to expected_status_code. We will create a new incident if the status code returned from the server is not in the list of expected status codes.
     */
    expectedStatusCodes?: pulumi.Input<pulumi.Input<number>[]>;
    /**
     * Set the expiration escalation policy for the monitor. It is used for SSL certificate and domain expiration checks. When set to null, an e-mail is sent to the entire team.
     */
    expirationPolicyId?: pulumi.Input<number>;
    /**
     * Set to true for the monitor to follow redirects.
     */
    followRedirects?: pulumi.Input<boolean>;
    /**
     * HTTP Method used to make a request. Valid options: GET, HEAD, POST, PUT, PATCH
     */
    httpMethod?: pulumi.Input<string>;
    /**
     * Valid values:
     *
     *     `ipv4` Use IPv4 only,
     *
     *     `ipv6` Use IPv6 only.
     */
    ipVersion?: pulumi.Input<string>;
    /**
     * When the website was last checked.
     */
    lastCheckedAt?: pulumi.Input<string>;
    /**
     * An array of maintenance days to set. If a maintenance window is overnight both affected days should be set. Allowed values are ["mon", "tue", "wed", "thu", "fri", "sat", "sun"] or any subset of these days.
     */
    maintenanceDays?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Start of the maintenance window each day. We won't check your website during this window. Example: "01:00:00"
     */
    maintenanceFrom?: pulumi.Input<string>;
    /**
     * The timezone to use for the maintenance window each day. Defaults to UTC. The accepted values can be found in the Rails TimeZone documentation. https://api.rubyonrails.org/classes/ActiveSupport/TimeZone.html
     */
    maintenanceTimezone?: pulumi.Input<string>;
    /**
     * End of the maintenance window each day. Example: "03:00:00"
     */
    maintenanceTo?: pulumi.Input<string>;
    /**
     * Set this attribute if you want to add this monitor to a monitor group.
     */
    monitorGroupId?: pulumi.Input<number>;
    /**
     * Valid values:
     *
     *     `status` We will check your website for 2XX HTTP status code.
     *
     * 	`expected_status_code` We will check if your website returned one of the values in expected_status_codes.
     *
     *     `keyword` We will check if your website contains the required_keyword.
     *
     *     `keyword_absence` We will check if your website doesn't contain the required_keyword.
     *
     *     `ping` We will ping your host specified in the url parameter.
     *
     *     `tcp` We will test a TCP port at your host specified in the url parameter
     * (port is required).
     *
     *     `udp` We will test a UDP port at your host specified in the url parameter
     * (port and required_keyword are required).
     *
     *     `smtp` We will check for a SMTP server at the host specified in the url parameter
     * (port is required, and can be one of 25, 465, 587, or a combination of those ports separated by comma).
     *
     *     `pop` We will check for a POP3 server at the host specified in the url parameter
     * (port is required, and can be 110, 995, or both).
     *
     *     `imap` We will check for an IMAP server at the host specified in the url parameter
     * (port is required, and can be 143, 993, or both).
     *
     *     `dns` We will check for a DNS server at the host specified in the url parameter
     * (request_body is required, and should contain the domain to query the DNS server with).
     *
     *     `playwright` We will run the scenario defined by playwright_script, identified in the UI by scenario_name
     */
    monitorType?: pulumi.Input<string>;
    /**
     * Set to true to pause monitoring - we won't notify you about downtime. Set to false to resume monitoring.
     */
    paused?: pulumi.Input<boolean>;
    /**
     * The time when this monitor was paused.
     */
    pausedAt?: pulumi.Input<string>;
    /**
     * For Playwright monitors, the JavaScript source code of the scenario.
     */
    playwrightScript?: pulumi.Input<string>;
    /**
     * Set the escalation policy for the monitor.
     */
    policyId?: pulumi.Input<string>;
    /**
     * Required if monitor_type is set to tcp, udp, smtp, pop, or imap. tcp and udp monitors accept any ports, while smtp, pop, and imap accept only the specified ports corresponding with their servers (e.g. "25,465,587" for smtp).
     */
    port?: pulumi.Input<string>;
    /**
     * Pronounceable name of the monitor. We will use this when we call you. Try to make it tongue-friendly, please?
     */
    pronounceableName?: pulumi.Input<string>;
    /**
     * Whether to send a push notification when a new incident is created.
     */
    push?: pulumi.Input<boolean>;
    /**
     * How long the monitor must be up to automatically mark an incident as resolved after being down. In seconds.
     */
    recoveryPeriod?: pulumi.Input<number>;
    /**
     * An array of regions to set. Allowed values are ["us", "eu", "as", "au"] or any subset of these regions.
     */
    regions?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Set to true to keep cookies when redirecting.
     */
    rememberCookies?: pulumi.Input<boolean>;
    /**
     * Request body for POST, PUT, PATCH requests. Required if monitor_type is set to dns (domain to query the DNS server with).
     */
    requestBody?: pulumi.Input<string>;
    /**
     * An array of request headers, consisting of name and value pairs
     */
    requestHeaders?: pulumi.Input<pulumi.Input<{[key: string]: pulumi.Input<string>}>[]>;
    /**
     * How long to wait before timing out the request?
     *   - For Server and Port monitors (types `ping`, `tcp`, `udp`, `smtp`, `pop`, `imap` and `dns`) the timeout is specified in *milliseconds*. Valid options: 500, 1000, 2000, 3000, 5000.
     *   - For Playwright monitors (type `playwright`), this determines the Playwright scenario timeout instead in *seconds*. Valid options: 15, 30, 45, 60.
     *   - For all other monitors, the timeout is specified in *seconds*. Valid options: 2, 3, 5, 10, 15, 30, 45, 60.
     */
    requestTimeout?: pulumi.Input<number>;
    /**
     * Required if monitor_type is set to keyword  or udp. We will create a new incident if this keyword is missing on your page.
     */
    requiredKeyword?: pulumi.Input<string>;
    /**
     * For Playwright monitors, the scenario name identifying the monitor in the UI. For Playwright monitors, either `url` or `scenario_name` must be provided.
     */
    scenarioName?: pulumi.Input<string>;
    /**
     * Whether to send an SMS when a new incident is created.
     */
    sms?: pulumi.Input<boolean>;
    /**
     * How many days before the SSL certificate expires do you want to be alerted? Valid values are 1, 2, 3, 7, 14, 30, and 60. Set to -1 to disable SSL expiration check.
     */
    sslExpiration?: pulumi.Input<number>;
    /**
     * The status of this website check.
     */
    status?: pulumi.Input<string>;
    /**
     * Used to specify the team the resource should be created in when using global tokens.
     */
    teamName?: pulumi.Input<string>;
    /**
     * How long to wait before escalating the incident alert to the team. Leave blank to disable escalating to the entire team. In seconds.
     */
    teamWait?: pulumi.Input<number>;
    /**
     * The time when this monitor was updated.
     */
    updatedAt?: pulumi.Input<string>;
    /**
     * URL of your website or the host you want to ping (see monitor_type below). Required for all monitor types except Playwright. For Playwright monitors, either `url` or `scenario_name` must be provided.
     */
    url?: pulumi.Input<string>;
    /**
     * Should we verify SSL certificate validity?
     */
    verifySsl?: pulumi.Input<boolean>;
}

/**
 * The set of arguments for constructing a Monitor resource.
 */
export interface MonitorArgs {
    /**
     * Basic HTTP authentication password to include with the request.
     */
    authPassword?: pulumi.Input<string>;
    /**
     * Basic HTTP authentication username to include with the request.
     */
    authUsername?: pulumi.Input<string>;
    /**
     * Whether to call when a new incident is created.
     */
    call?: pulumi.Input<boolean>;
    /**
     * How often should we check your website? In seconds.
     */
    checkFrequency?: pulumi.Input<number>;
    /**
     * How long should we wait after observing a failure before we start a new incident? In seconds.
     */
    confirmationPeriod?: pulumi.Input<number>;
    /**
     * Whether to send a critical push notification that ignores the mute switch and Do not Disturb mode when a new incident is created.
     */
    criticalAlert?: pulumi.Input<boolean>;
    /**
     * How many days before the domain expires do you want to be alerted? Valid values are 1, 2, 3, 7, 14, 30, and 60. Set to -1 to disable domain expiration check.
     */
    domainExpiration?: pulumi.Input<number>;
    /**
     * Whether to send an email when a new incident is created.
     */
    email?: pulumi.Input<boolean>;
    /**
     * For Playwright monitors, the environment variables that can be used in the scenario. Example: `{ "PASSWORD" = "passw0rd" }`.
     */
    environmentVariables?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
    /**
     * Required if monitor_type is set to expected_status_code. We will create a new incident if the status code returned from the server is not in the list of expected status codes.
     */
    expectedStatusCodes?: pulumi.Input<pulumi.Input<number>[]>;
    /**
     * Set the expiration escalation policy for the monitor. It is used for SSL certificate and domain expiration checks. When set to null, an e-mail is sent to the entire team.
     */
    expirationPolicyId?: pulumi.Input<number>;
    /**
     * Set to true for the monitor to follow redirects.
     */
    followRedirects?: pulumi.Input<boolean>;
    /**
     * HTTP Method used to make a request. Valid options: GET, HEAD, POST, PUT, PATCH
     */
    httpMethod?: pulumi.Input<string>;
    /**
     * Valid values:
     *
     *     `ipv4` Use IPv4 only,
     *
     *     `ipv6` Use IPv6 only.
     */
    ipVersion?: pulumi.Input<string>;
    /**
     * An array of maintenance days to set. If a maintenance window is overnight both affected days should be set. Allowed values are ["mon", "tue", "wed", "thu", "fri", "sat", "sun"] or any subset of these days.
     */
    maintenanceDays?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Start of the maintenance window each day. We won't check your website during this window. Example: "01:00:00"
     */
    maintenanceFrom?: pulumi.Input<string>;
    /**
     * The timezone to use for the maintenance window each day. Defaults to UTC. The accepted values can be found in the Rails TimeZone documentation. https://api.rubyonrails.org/classes/ActiveSupport/TimeZone.html
     */
    maintenanceTimezone?: pulumi.Input<string>;
    /**
     * End of the maintenance window each day. Example: "03:00:00"
     */
    maintenanceTo?: pulumi.Input<string>;
    /**
     * Set this attribute if you want to add this monitor to a monitor group.
     */
    monitorGroupId?: pulumi.Input<number>;
    /**
     * Valid values:
     *
     *     `status` We will check your website for 2XX HTTP status code.
     *
     * 	`expected_status_code` We will check if your website returned one of the values in expected_status_codes.
     *
     *     `keyword` We will check if your website contains the required_keyword.
     *
     *     `keyword_absence` We will check if your website doesn't contain the required_keyword.
     *
     *     `ping` We will ping your host specified in the url parameter.
     *
     *     `tcp` We will test a TCP port at your host specified in the url parameter
     * (port is required).
     *
     *     `udp` We will test a UDP port at your host specified in the url parameter
     * (port and required_keyword are required).
     *
     *     `smtp` We will check for a SMTP server at the host specified in the url parameter
     * (port is required, and can be one of 25, 465, 587, or a combination of those ports separated by comma).
     *
     *     `pop` We will check for a POP3 server at the host specified in the url parameter
     * (port is required, and can be 110, 995, or both).
     *
     *     `imap` We will check for an IMAP server at the host specified in the url parameter
     * (port is required, and can be 143, 993, or both).
     *
     *     `dns` We will check for a DNS server at the host specified in the url parameter
     * (request_body is required, and should contain the domain to query the DNS server with).
     *
     *     `playwright` We will run the scenario defined by playwright_script, identified in the UI by scenario_name
     */
    monitorType: pulumi.Input<string>;
    /**
     * Set to true to pause monitoring - we won't notify you about downtime. Set to false to resume monitoring.
     */
    paused?: pulumi.Input<boolean>;
    /**
     * For Playwright monitors, the JavaScript source code of the scenario.
     */
    playwrightScript?: pulumi.Input<string>;
    /**
     * Set the escalation policy for the monitor.
     */
    policyId?: pulumi.Input<string>;
    /**
     * Required if monitor_type is set to tcp, udp, smtp, pop, or imap. tcp and udp monitors accept any ports, while smtp, pop, and imap accept only the specified ports corresponding with their servers (e.g. "25,465,587" for smtp).
     */
    port?: pulumi.Input<string>;
    /**
     * Pronounceable name of the monitor. We will use this when we call you. Try to make it tongue-friendly, please?
     */
    pronounceableName?: pulumi.Input<string>;
    /**
     * Whether to send a push notification when a new incident is created.
     */
    push?: pulumi.Input<boolean>;
    /**
     * How long the monitor must be up to automatically mark an incident as resolved after being down. In seconds.
     */
    recoveryPeriod?: pulumi.Input<number>;
    /**
     * An array of regions to set. Allowed values are ["us", "eu", "as", "au"] or any subset of these regions.
     */
    regions?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Set to true to keep cookies when redirecting.
     */
    rememberCookies?: pulumi.Input<boolean>;
    /**
     * Request body for POST, PUT, PATCH requests. Required if monitor_type is set to dns (domain to query the DNS server with).
     */
    requestBody?: pulumi.Input<string>;
    /**
     * An array of request headers, consisting of name and value pairs
     */
    requestHeaders?: pulumi.Input<pulumi.Input<{[key: string]: pulumi.Input<string>}>[]>;
    /**
     * How long to wait before timing out the request?
     *   - For Server and Port monitors (types `ping`, `tcp`, `udp`, `smtp`, `pop`, `imap` and `dns`) the timeout is specified in *milliseconds*. Valid options: 500, 1000, 2000, 3000, 5000.
     *   - For Playwright monitors (type `playwright`), this determines the Playwright scenario timeout instead in *seconds*. Valid options: 15, 30, 45, 60.
     *   - For all other monitors, the timeout is specified in *seconds*. Valid options: 2, 3, 5, 10, 15, 30, 45, 60.
     */
    requestTimeout?: pulumi.Input<number>;
    /**
     * Required if monitor_type is set to keyword  or udp. We will create a new incident if this keyword is missing on your page.
     */
    requiredKeyword?: pulumi.Input<string>;
    /**
     * For Playwright monitors, the scenario name identifying the monitor in the UI. For Playwright monitors, either `url` or `scenario_name` must be provided.
     */
    scenarioName?: pulumi.Input<string>;
    /**
     * Whether to send an SMS when a new incident is created.
     */
    sms?: pulumi.Input<boolean>;
    /**
     * How many days before the SSL certificate expires do you want to be alerted? Valid values are 1, 2, 3, 7, 14, 30, and 60. Set to -1 to disable SSL expiration check.
     */
    sslExpiration?: pulumi.Input<number>;
    /**
     * Used to specify the team the resource should be created in when using global tokens.
     */
    teamName?: pulumi.Input<string>;
    /**
     * How long to wait before escalating the incident alert to the team. Leave blank to disable escalating to the entire team. In seconds.
     */
    teamWait?: pulumi.Input<number>;
    /**
     * URL of your website or the host you want to ping (see monitor_type below). Required for all monitor types except Playwright. For Playwright monitors, either `url` or `scenario_name` must be provided.
     */
    url?: pulumi.Input<string>;
    /**
     * Should we verify SSL certificate validity?
     */
    verifySsl?: pulumi.Input<boolean>;
}
