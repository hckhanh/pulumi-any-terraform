// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface CatalogRecordAttribute {
    /**
     * ID of the target Catalog attribute.
     */
    attributeId: string;
    /**
     * Name of the Catalog attribute.
     */
    attributeName: string;
    /**
     * Email of the referenced user when type is `User`.
     */
    email?: string;
    /**
     * ID of the referenced item when type is different than `String`.
     */
    itemId?: string;
    /**
     * Name of the referenced item when type is different than `String`.
     */
    name?: string;
    /**
     * Value types can be grouped into 2 main categories:
     *   - **Scalar**: `String`
     *   - **Reference**: `User`, `Team`, `Policy`, `Schedule`, `SlackIntegration`, `LinearIntegration`, `JiraIntegration`, `MicrosoftTeamsWebhook`, `ZapierWebhook`, `NativeWebhook`, `PagerDutyWebhook`
     *   
     *   The value of a **Scalar** type is defined using the value field.
     *   
     *   The value of a **Reference** type is defined using one of the following fields:
     *   - <span pulumi-lang-nodejs="`itemId`" pulumi-lang-dotnet="`ItemId`" pulumi-lang-go="`itemId`" pulumi-lang-python="`item_id`" pulumi-lang-yaml="`itemId`" pulumi-lang-java="`itemId`">`item_id`</span> - great choice when you know the ID of the target item.
     *   - <span pulumi-lang-nodejs="`email`" pulumi-lang-dotnet="`Email`" pulumi-lang-go="`email`" pulumi-lang-python="`email`" pulumi-lang-yaml="`email`" pulumi-lang-java="`email`">`email`</span> - your go-to choice when you're referencing users.
     *   - <span pulumi-lang-nodejs="`name`" pulumi-lang-dotnet="`Name`" pulumi-lang-go="`name`" pulumi-lang-python="`name`" pulumi-lang-yaml="`name`" pulumi-lang-java="`name`">`name`</span> - can be used to reference other items like teams, policies, etc.
     *   
     *   **The reference types require the presence of at least one of the three fields: <span pulumi-lang-nodejs="`itemId`" pulumi-lang-dotnet="`ItemId`" pulumi-lang-go="`itemId`" pulumi-lang-python="`item_id`" pulumi-lang-yaml="`itemId`" pulumi-lang-java="`itemId`">`item_id`</span>, <span pulumi-lang-nodejs="`name`" pulumi-lang-dotnet="`Name`" pulumi-lang-go="`name`" pulumi-lang-python="`name`" pulumi-lang-yaml="`name`" pulumi-lang-java="`name`">`name`</span>, <span pulumi-lang-nodejs="`email`" pulumi-lang-dotnet="`Email`" pulumi-lang-go="`email`" pulumi-lang-python="`email`" pulumi-lang-yaml="`email`" pulumi-lang-java="`email`">`email`</span>.**
     */
    type?: string;
    /**
     * Value when type is String.
     */
    value?: string;
}

export interface EmailIntegrationAcknowledgedAlertIdField {
    /**
     * How should we extract content the field. Should be a valid Regex when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is match_regex.
     */
    content: string;
    /**
     * When should we start extracting content for the field. Should be present when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is either<span pulumi-lang-nodejs=" matchBetween " pulumi-lang-dotnet=" MatchBetween " pulumi-lang-go=" matchBetween " pulumi-lang-python=" match_between " pulumi-lang-yaml=" matchBetween " pulumi-lang-java=" matchBetween "> match_between </span>or match_after.
     */
    contentAfter: string;
    /**
     * When should we stop extracting content for the field. Should be present when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is either<span pulumi-lang-nodejs=" matchBetween " pulumi-lang-dotnet=" MatchBetween " pulumi-lang-go=" matchBetween " pulumi-lang-python=" match_between " pulumi-lang-yaml=" matchBetween " pulumi-lang-java=" matchBetween "> match_between </span>or match_before.
     */
    contentBefore: string;
    /**
     * The target of the field. Can be any of the following: from_email, subject, or body for email integrations or query_string, header, body, json and xml for incoming webhooks.
     */
    fieldTarget: string;
    /**
     * The match type of the field. Can be any of the following: match_before, match_after, match_between, match_regex, or match_everything.
     */
    matchType: string;
    /**
     * The name of the field.
     */
    name: string;
    /**
     * A special type of the field. Can be<span pulumi-lang-nodejs=" alertId " pulumi-lang-dotnet=" AlertId " pulumi-lang-go=" alertId " pulumi-lang-python=" alert_id " pulumi-lang-yaml=" alertId " pulumi-lang-java=" alertId "> alert_id </span>or cause or otherwise null for a custom field.
     */
    specialType: string;
    /**
     * The target field within the content of the field_target. Should be a JSON key when<span pulumi-lang-nodejs=" fieldTarget " pulumi-lang-dotnet=" FieldTarget " pulumi-lang-go=" fieldTarget " pulumi-lang-python=" field_target " pulumi-lang-yaml=" fieldTarget " pulumi-lang-java=" fieldTarget "> field_target </span>is json, a CSS selector when<span pulumi-lang-nodejs=" fieldTarget " pulumi-lang-dotnet=" FieldTarget " pulumi-lang-go=" fieldTarget " pulumi-lang-python=" field_target " pulumi-lang-yaml=" fieldTarget " pulumi-lang-java=" fieldTarget "> field_target </span>is XML, name of the header for headers or a parameter name for query parameters
     */
    targetField: string;
}

export interface EmailIntegrationAcknowledgedRule {
    /**
     * The content we should match to satisfy the rule. Should be a valid Regex when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is match_regex.
     */
    content: string;
    /**
     * The type of the rule. Can be any of the following: contains, contains_not, matches_regex, matches_regex_not, equals, or equals_not.
     */
    matchType: string;
    /**
     * The target of the rule. Can be any of the following: from_email, subject, or body for email integrations or query_string, header, body, json and xml for incoming webhooks.
     */
    ruleTarget: string;
    /**
     * The target field within the content of the rule_target. Should be a JSON key when<span pulumi-lang-nodejs=" ruleTarget " pulumi-lang-dotnet=" RuleTarget " pulumi-lang-go=" ruleTarget " pulumi-lang-python=" rule_target " pulumi-lang-yaml=" ruleTarget " pulumi-lang-java=" ruleTarget "> rule_target </span>is json, a CSS selector when<span pulumi-lang-nodejs=" ruleTarget " pulumi-lang-dotnet=" RuleTarget " pulumi-lang-go=" ruleTarget " pulumi-lang-python=" rule_target " pulumi-lang-yaml=" ruleTarget " pulumi-lang-java=" ruleTarget "> rule_target </span>is XML, name of the header for headers or a parameter name for query parameters
     */
    targetField: string;
}

export interface EmailIntegrationCauseField {
    /**
     * How should we extract content the field. Should be a valid Regex when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is match_regex.
     */
    content: string;
    /**
     * When should we start extracting content for the field. Should be present when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is either<span pulumi-lang-nodejs=" matchBetween " pulumi-lang-dotnet=" MatchBetween " pulumi-lang-go=" matchBetween " pulumi-lang-python=" match_between " pulumi-lang-yaml=" matchBetween " pulumi-lang-java=" matchBetween "> match_between </span>or match_after.
     */
    contentAfter: string;
    /**
     * When should we stop extracting content for the field. Should be present when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is either<span pulumi-lang-nodejs=" matchBetween " pulumi-lang-dotnet=" MatchBetween " pulumi-lang-go=" matchBetween " pulumi-lang-python=" match_between " pulumi-lang-yaml=" matchBetween " pulumi-lang-java=" matchBetween "> match_between </span>or match_before.
     */
    contentBefore: string;
    /**
     * The target of the field. Can be any of the following: from_email, subject, or body for email integrations or query_string, header, body, json and xml for incoming webhooks.
     */
    fieldTarget: string;
    /**
     * The match type of the field. Can be any of the following: match_before, match_after, match_between, match_regex, or match_everything.
     */
    matchType: string;
    /**
     * The name of the field.
     */
    name: string;
    /**
     * A special type of the field. Can be<span pulumi-lang-nodejs=" alertId " pulumi-lang-dotnet=" AlertId " pulumi-lang-go=" alertId " pulumi-lang-python=" alert_id " pulumi-lang-yaml=" alertId " pulumi-lang-java=" alertId "> alert_id </span>or cause or otherwise null for a custom field.
     */
    specialType: string;
    /**
     * The target field within the content of the field_target. Should be a JSON key when<span pulumi-lang-nodejs=" fieldTarget " pulumi-lang-dotnet=" FieldTarget " pulumi-lang-go=" fieldTarget " pulumi-lang-python=" field_target " pulumi-lang-yaml=" fieldTarget " pulumi-lang-java=" fieldTarget "> field_target </span>is json, a CSS selector when<span pulumi-lang-nodejs=" fieldTarget " pulumi-lang-dotnet=" FieldTarget " pulumi-lang-go=" fieldTarget " pulumi-lang-python=" field_target " pulumi-lang-yaml=" fieldTarget " pulumi-lang-java=" fieldTarget "> field_target </span>is XML, name of the header for headers or a parameter name for query parameters
     */
    targetField: string;
}

export interface EmailIntegrationOtherAcknowledgedField {
    /**
     * How should we extract content the field. Should be a valid Regex when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is match_regex.
     */
    content: string;
    /**
     * When should we start extracting content for the field. Should be present when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is either<span pulumi-lang-nodejs=" matchBetween " pulumi-lang-dotnet=" MatchBetween " pulumi-lang-go=" matchBetween " pulumi-lang-python=" match_between " pulumi-lang-yaml=" matchBetween " pulumi-lang-java=" matchBetween "> match_between </span>or match_after.
     */
    contentAfter: string;
    /**
     * When should we stop extracting content for the field. Should be present when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is either<span pulumi-lang-nodejs=" matchBetween " pulumi-lang-dotnet=" MatchBetween " pulumi-lang-go=" matchBetween " pulumi-lang-python=" match_between " pulumi-lang-yaml=" matchBetween " pulumi-lang-java=" matchBetween "> match_between </span>or match_before.
     */
    contentBefore: string;
    /**
     * The target of the field. Can be any of the following: from_email, subject, or body for email integrations or query_string, header, body, json and xml for incoming webhooks.
     */
    fieldTarget: string;
    /**
     * The match type of the field. Can be any of the following: match_before, match_after, match_between, match_regex, or match_everything.
     */
    matchType: string;
    /**
     * The name of the field.
     */
    name: string;
    /**
     * A special type of the field. Can be<span pulumi-lang-nodejs=" alertId " pulumi-lang-dotnet=" AlertId " pulumi-lang-go=" alertId " pulumi-lang-python=" alert_id " pulumi-lang-yaml=" alertId " pulumi-lang-java=" alertId "> alert_id </span>or cause or otherwise null for a custom field.
     */
    specialType: string;
    /**
     * The target field within the content of the field_target. Should be a JSON key when<span pulumi-lang-nodejs=" fieldTarget " pulumi-lang-dotnet=" FieldTarget " pulumi-lang-go=" fieldTarget " pulumi-lang-python=" field_target " pulumi-lang-yaml=" fieldTarget " pulumi-lang-java=" fieldTarget "> field_target </span>is json, a CSS selector when<span pulumi-lang-nodejs=" fieldTarget " pulumi-lang-dotnet=" FieldTarget " pulumi-lang-go=" fieldTarget " pulumi-lang-python=" field_target " pulumi-lang-yaml=" fieldTarget " pulumi-lang-java=" fieldTarget "> field_target </span>is XML, name of the header for headers or a parameter name for query parameters
     */
    targetField: string;
}

export interface EmailIntegrationOtherResolvedField {
    /**
     * How should we extract content the field. Should be a valid Regex when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is match_regex.
     */
    content: string;
    /**
     * When should we start extracting content for the field. Should be present when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is either<span pulumi-lang-nodejs=" matchBetween " pulumi-lang-dotnet=" MatchBetween " pulumi-lang-go=" matchBetween " pulumi-lang-python=" match_between " pulumi-lang-yaml=" matchBetween " pulumi-lang-java=" matchBetween "> match_between </span>or match_after.
     */
    contentAfter: string;
    /**
     * When should we stop extracting content for the field. Should be present when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is either<span pulumi-lang-nodejs=" matchBetween " pulumi-lang-dotnet=" MatchBetween " pulumi-lang-go=" matchBetween " pulumi-lang-python=" match_between " pulumi-lang-yaml=" matchBetween " pulumi-lang-java=" matchBetween "> match_between </span>or match_before.
     */
    contentBefore: string;
    /**
     * The target of the field. Can be any of the following: from_email, subject, or body for email integrations or query_string, header, body, json and xml for incoming webhooks.
     */
    fieldTarget: string;
    /**
     * The match type of the field. Can be any of the following: match_before, match_after, match_between, match_regex, or match_everything.
     */
    matchType: string;
    /**
     * The name of the field.
     */
    name: string;
    /**
     * A special type of the field. Can be<span pulumi-lang-nodejs=" alertId " pulumi-lang-dotnet=" AlertId " pulumi-lang-go=" alertId " pulumi-lang-python=" alert_id " pulumi-lang-yaml=" alertId " pulumi-lang-java=" alertId "> alert_id </span>or cause or otherwise null for a custom field.
     */
    specialType: string;
    /**
     * The target field within the content of the field_target. Should be a JSON key when<span pulumi-lang-nodejs=" fieldTarget " pulumi-lang-dotnet=" FieldTarget " pulumi-lang-go=" fieldTarget " pulumi-lang-python=" field_target " pulumi-lang-yaml=" fieldTarget " pulumi-lang-java=" fieldTarget "> field_target </span>is json, a CSS selector when<span pulumi-lang-nodejs=" fieldTarget " pulumi-lang-dotnet=" FieldTarget " pulumi-lang-go=" fieldTarget " pulumi-lang-python=" field_target " pulumi-lang-yaml=" fieldTarget " pulumi-lang-java=" fieldTarget "> field_target </span>is XML, name of the header for headers or a parameter name for query parameters
     */
    targetField: string;
}

export interface EmailIntegrationOtherStartedField {
    /**
     * How should we extract content the field. Should be a valid Regex when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is match_regex.
     */
    content: string;
    /**
     * When should we start extracting content for the field. Should be present when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is either<span pulumi-lang-nodejs=" matchBetween " pulumi-lang-dotnet=" MatchBetween " pulumi-lang-go=" matchBetween " pulumi-lang-python=" match_between " pulumi-lang-yaml=" matchBetween " pulumi-lang-java=" matchBetween "> match_between </span>or match_after.
     */
    contentAfter: string;
    /**
     * When should we stop extracting content for the field. Should be present when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is either<span pulumi-lang-nodejs=" matchBetween " pulumi-lang-dotnet=" MatchBetween " pulumi-lang-go=" matchBetween " pulumi-lang-python=" match_between " pulumi-lang-yaml=" matchBetween " pulumi-lang-java=" matchBetween "> match_between </span>or match_before.
     */
    contentBefore: string;
    /**
     * The target of the field. Can be any of the following: from_email, subject, or body for email integrations or query_string, header, body, json and xml for incoming webhooks.
     */
    fieldTarget: string;
    /**
     * The match type of the field. Can be any of the following: match_before, match_after, match_between, match_regex, or match_everything.
     */
    matchType: string;
    /**
     * The name of the field.
     */
    name: string;
    /**
     * A special type of the field. Can be<span pulumi-lang-nodejs=" alertId " pulumi-lang-dotnet=" AlertId " pulumi-lang-go=" alertId " pulumi-lang-python=" alert_id " pulumi-lang-yaml=" alertId " pulumi-lang-java=" alertId "> alert_id </span>or cause or otherwise null for a custom field.
     */
    specialType: string;
    /**
     * The target field within the content of the field_target. Should be a JSON key when<span pulumi-lang-nodejs=" fieldTarget " pulumi-lang-dotnet=" FieldTarget " pulumi-lang-go=" fieldTarget " pulumi-lang-python=" field_target " pulumi-lang-yaml=" fieldTarget " pulumi-lang-java=" fieldTarget "> field_target </span>is json, a CSS selector when<span pulumi-lang-nodejs=" fieldTarget " pulumi-lang-dotnet=" FieldTarget " pulumi-lang-go=" fieldTarget " pulumi-lang-python=" field_target " pulumi-lang-yaml=" fieldTarget " pulumi-lang-java=" fieldTarget "> field_target </span>is XML, name of the header for headers or a parameter name for query parameters
     */
    targetField: string;
}

export interface EmailIntegrationResolvedAlertIdField {
    /**
     * How should we extract content the field. Should be a valid Regex when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is match_regex.
     */
    content: string;
    /**
     * When should we start extracting content for the field. Should be present when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is either<span pulumi-lang-nodejs=" matchBetween " pulumi-lang-dotnet=" MatchBetween " pulumi-lang-go=" matchBetween " pulumi-lang-python=" match_between " pulumi-lang-yaml=" matchBetween " pulumi-lang-java=" matchBetween "> match_between </span>or match_after.
     */
    contentAfter: string;
    /**
     * When should we stop extracting content for the field. Should be present when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is either<span pulumi-lang-nodejs=" matchBetween " pulumi-lang-dotnet=" MatchBetween " pulumi-lang-go=" matchBetween " pulumi-lang-python=" match_between " pulumi-lang-yaml=" matchBetween " pulumi-lang-java=" matchBetween "> match_between </span>or match_before.
     */
    contentBefore: string;
    /**
     * The target of the field. Can be any of the following: from_email, subject, or body for email integrations or query_string, header, body, json and xml for incoming webhooks.
     */
    fieldTarget: string;
    /**
     * The match type of the field. Can be any of the following: match_before, match_after, match_between, match_regex, or match_everything.
     */
    matchType: string;
    /**
     * The name of the field.
     */
    name: string;
    /**
     * A special type of the field. Can be<span pulumi-lang-nodejs=" alertId " pulumi-lang-dotnet=" AlertId " pulumi-lang-go=" alertId " pulumi-lang-python=" alert_id " pulumi-lang-yaml=" alertId " pulumi-lang-java=" alertId "> alert_id </span>or cause or otherwise null for a custom field.
     */
    specialType: string;
    /**
     * The target field within the content of the field_target. Should be a JSON key when<span pulumi-lang-nodejs=" fieldTarget " pulumi-lang-dotnet=" FieldTarget " pulumi-lang-go=" fieldTarget " pulumi-lang-python=" field_target " pulumi-lang-yaml=" fieldTarget " pulumi-lang-java=" fieldTarget "> field_target </span>is json, a CSS selector when<span pulumi-lang-nodejs=" fieldTarget " pulumi-lang-dotnet=" FieldTarget " pulumi-lang-go=" fieldTarget " pulumi-lang-python=" field_target " pulumi-lang-yaml=" fieldTarget " pulumi-lang-java=" fieldTarget "> field_target </span>is XML, name of the header for headers or a parameter name for query parameters
     */
    targetField: string;
}

export interface EmailIntegrationResolvedRule {
    /**
     * The content we should match to satisfy the rule. Should be a valid Regex when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is match_regex.
     */
    content: string;
    /**
     * The type of the rule. Can be any of the following: contains, contains_not, matches_regex, matches_regex_not, equals, or equals_not.
     */
    matchType: string;
    /**
     * The target of the rule. Can be any of the following: from_email, subject, or body for email integrations or query_string, header, body, json and xml for incoming webhooks.
     */
    ruleTarget: string;
    /**
     * The target field within the content of the rule_target. Should be a JSON key when<span pulumi-lang-nodejs=" ruleTarget " pulumi-lang-dotnet=" RuleTarget " pulumi-lang-go=" ruleTarget " pulumi-lang-python=" rule_target " pulumi-lang-yaml=" ruleTarget " pulumi-lang-java=" ruleTarget "> rule_target </span>is json, a CSS selector when<span pulumi-lang-nodejs=" ruleTarget " pulumi-lang-dotnet=" RuleTarget " pulumi-lang-go=" ruleTarget " pulumi-lang-python=" rule_target " pulumi-lang-yaml=" ruleTarget " pulumi-lang-java=" ruleTarget "> rule_target </span>is XML, name of the header for headers or a parameter name for query parameters
     */
    targetField: string;
}

export interface EmailIntegrationStartedAlertIdField {
    /**
     * How should we extract content the field. Should be a valid Regex when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is match_regex.
     */
    content: string;
    /**
     * When should we start extracting content for the field. Should be present when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is either<span pulumi-lang-nodejs=" matchBetween " pulumi-lang-dotnet=" MatchBetween " pulumi-lang-go=" matchBetween " pulumi-lang-python=" match_between " pulumi-lang-yaml=" matchBetween " pulumi-lang-java=" matchBetween "> match_between </span>or match_after.
     */
    contentAfter: string;
    /**
     * When should we stop extracting content for the field. Should be present when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is either<span pulumi-lang-nodejs=" matchBetween " pulumi-lang-dotnet=" MatchBetween " pulumi-lang-go=" matchBetween " pulumi-lang-python=" match_between " pulumi-lang-yaml=" matchBetween " pulumi-lang-java=" matchBetween "> match_between </span>or match_before.
     */
    contentBefore: string;
    /**
     * The target of the field. Can be any of the following: from_email, subject, or body for email integrations or query_string, header, body, json and xml for incoming webhooks.
     */
    fieldTarget: string;
    /**
     * The match type of the field. Can be any of the following: match_before, match_after, match_between, match_regex, or match_everything.
     */
    matchType: string;
    /**
     * The name of the field.
     */
    name: string;
    /**
     * A special type of the field. Can be<span pulumi-lang-nodejs=" alertId " pulumi-lang-dotnet=" AlertId " pulumi-lang-go=" alertId " pulumi-lang-python=" alert_id " pulumi-lang-yaml=" alertId " pulumi-lang-java=" alertId "> alert_id </span>or cause or otherwise null for a custom field.
     */
    specialType: string;
    /**
     * The target field within the content of the field_target. Should be a JSON key when<span pulumi-lang-nodejs=" fieldTarget " pulumi-lang-dotnet=" FieldTarget " pulumi-lang-go=" fieldTarget " pulumi-lang-python=" field_target " pulumi-lang-yaml=" fieldTarget " pulumi-lang-java=" fieldTarget "> field_target </span>is json, a CSS selector when<span pulumi-lang-nodejs=" fieldTarget " pulumi-lang-dotnet=" FieldTarget " pulumi-lang-go=" fieldTarget " pulumi-lang-python=" field_target " pulumi-lang-yaml=" fieldTarget " pulumi-lang-java=" fieldTarget "> field_target </span>is XML, name of the header for headers or a parameter name for query parameters
     */
    targetField: string;
}

export interface EmailIntegrationStartedRule {
    /**
     * The content we should match to satisfy the rule. Should be a valid Regex when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is match_regex.
     */
    content: string;
    /**
     * The type of the rule. Can be any of the following: contains, contains_not, matches_regex, matches_regex_not, equals, or equals_not.
     */
    matchType: string;
    /**
     * The target of the rule. Can be any of the following: from_email, subject, or body for email integrations or query_string, header, body, json and xml for incoming webhooks.
     */
    ruleTarget: string;
    /**
     * The target field within the content of the rule_target. Should be a JSON key when<span pulumi-lang-nodejs=" ruleTarget " pulumi-lang-dotnet=" RuleTarget " pulumi-lang-go=" ruleTarget " pulumi-lang-python=" rule_target " pulumi-lang-yaml=" ruleTarget " pulumi-lang-java=" ruleTarget "> rule_target </span>is json, a CSS selector when<span pulumi-lang-nodejs=" ruleTarget " pulumi-lang-dotnet=" RuleTarget " pulumi-lang-go=" ruleTarget " pulumi-lang-python=" rule_target " pulumi-lang-yaml=" ruleTarget " pulumi-lang-java=" ruleTarget "> rule_target </span>is XML, name of the header for headers or a parameter name for query parameters
     */
    targetField: string;
}

export interface GetIncomingWebhookAcknowledgedAlertIdField {
    content: string;
    contentAfter: string;
    contentBefore: string;
    fieldTarget: string;
    matchType: string;
    name: string;
    specialType: string;
    targetField: string;
}

export interface GetIncomingWebhookAcknowledgedRule {
    content: string;
    matchType: string;
    ruleTarget: string;
    targetField: string;
}

export interface GetIncomingWebhookCauseField {
    content: string;
    contentAfter: string;
    contentBefore: string;
    fieldTarget: string;
    matchType: string;
    name: string;
    specialType: string;
    targetField: string;
}

export interface GetIncomingWebhookOtherAcknowledgedField {
    content: string;
    contentAfter: string;
    contentBefore: string;
    fieldTarget: string;
    matchType: string;
    name: string;
    specialType: string;
    targetField: string;
}

export interface GetIncomingWebhookOtherResolvedField {
    content: string;
    contentAfter: string;
    contentBefore: string;
    fieldTarget: string;
    matchType: string;
    name: string;
    specialType: string;
    targetField: string;
}

export interface GetIncomingWebhookOtherStartedField {
    content: string;
    contentAfter: string;
    contentBefore: string;
    fieldTarget: string;
    matchType: string;
    name: string;
    specialType: string;
    targetField: string;
}

export interface GetIncomingWebhookResolvedAlertIdField {
    content: string;
    contentAfter: string;
    contentBefore: string;
    fieldTarget: string;
    matchType: string;
    name: string;
    specialType: string;
    targetField: string;
}

export interface GetIncomingWebhookResolvedRule {
    content: string;
    matchType: string;
    ruleTarget: string;
    targetField: string;
}

export interface GetIncomingWebhookStartedAlertIdField {
    content: string;
    contentAfter: string;
    contentBefore: string;
    fieldTarget: string;
    matchType: string;
    name: string;
    specialType: string;
    targetField: string;
}

export interface GetIncomingWebhookStartedRule {
    content: string;
    matchType: string;
    ruleTarget: string;
    targetField: string;
}

export interface GetIncomingWebhookTitleField {
    content: string;
    contentAfter: string;
    contentBefore: string;
    fieldTarget: string;
    matchType: string;
    name: string;
    specialType: string;
    targetField: string;
}

export interface GetOnCallCalendarOnCallRotation {
    endRotationsAt: string;
    rotationInterval: string;
    rotationLength: number;
    startRotationsAt: string;
    users: string[];
}

export interface GetOnCallCalendarOnCallUser {
    email: string;
    firstName: string;
    id: string;
    lastName: string;
    phoneNumbers: string[];
}

export interface GetPolicyStep {
    comment: string;
    days: string[];
    metadataKey: string;
    metadataValue: outputs.GetPolicyStepMetadataValue[];
    metadataValues: string[];
    policyId: number;
    policyMetadataKey: string;
    reminderEnabled: boolean;
    reminderIntervalHours: number;
    stepMembers: outputs.GetPolicyStepStepMember[];
    timeFrom: string;
    timeTo: string;
    timezone: string;
    type: string;
    urgencyId: number;
    waitBefore: number;
    waitUntilTime: string;
    waitUntilTimezone: string;
}

export interface GetPolicyStepMetadataValue {
    email: string;
    itemId: string;
    name: string;
    type: string;
    value: string;
}

export interface GetPolicyStepStepMember {
    id: number;
    metadataKey: string;
    teamId: number;
    type: string;
}

export interface IncomingWebhookAcknowledgedAlertIdField {
    /**
     * How should we extract content the field. Should be a valid Regex when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is match_regex.
     */
    content: string;
    /**
     * When should we start extracting content for the field. Should be present when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is either<span pulumi-lang-nodejs=" matchBetween " pulumi-lang-dotnet=" MatchBetween " pulumi-lang-go=" matchBetween " pulumi-lang-python=" match_between " pulumi-lang-yaml=" matchBetween " pulumi-lang-java=" matchBetween "> match_between </span>or match_after.
     */
    contentAfter: string;
    /**
     * When should we stop extracting content for the field. Should be present when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is either<span pulumi-lang-nodejs=" matchBetween " pulumi-lang-dotnet=" MatchBetween " pulumi-lang-go=" matchBetween " pulumi-lang-python=" match_between " pulumi-lang-yaml=" matchBetween " pulumi-lang-java=" matchBetween "> match_between </span>or match_before.
     */
    contentBefore: string;
    /**
     * The target of the field. Can be any of the following: from_email, subject, or body for email integrations or query_string, header, body, json and xml for incoming webhooks.
     */
    fieldTarget: string;
    /**
     * The match type of the field. Can be any of the following: match_before, match_after, match_between, match_regex, or match_everything.
     */
    matchType: string;
    /**
     * The name of the field.
     */
    name: string;
    /**
     * A special type of the field. Can be<span pulumi-lang-nodejs=" alertId " pulumi-lang-dotnet=" AlertId " pulumi-lang-go=" alertId " pulumi-lang-python=" alert_id " pulumi-lang-yaml=" alertId " pulumi-lang-java=" alertId "> alert_id </span>or cause or otherwise null for a custom field.
     */
    specialType: string;
    /**
     * The target field within the content of the field_target. Should be a JSON key when<span pulumi-lang-nodejs=" fieldTarget " pulumi-lang-dotnet=" FieldTarget " pulumi-lang-go=" fieldTarget " pulumi-lang-python=" field_target " pulumi-lang-yaml=" fieldTarget " pulumi-lang-java=" fieldTarget "> field_target </span>is json, a CSS selector when<span pulumi-lang-nodejs=" fieldTarget " pulumi-lang-dotnet=" FieldTarget " pulumi-lang-go=" fieldTarget " pulumi-lang-python=" field_target " pulumi-lang-yaml=" fieldTarget " pulumi-lang-java=" fieldTarget "> field_target </span>is XML, name of the header for headers or a parameter name for query parameters
     */
    targetField: string;
}

export interface IncomingWebhookAcknowledgedRule {
    /**
     * The content we should match to satisfy the rule. Should be a valid Regex when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is match_regex.
     */
    content: string;
    /**
     * The type of the rule. Can be any of the following: contains, contains_not, matches_regex, matches_regex_not, equals, or equals_not.
     */
    matchType: string;
    /**
     * The target of the rule. Can be any of the following: from_email, subject, or body for email integrations or query_string, header, body, json and xml for incoming webhooks.
     */
    ruleTarget: string;
    /**
     * The target field within the content of the rule_target. Should be a JSON key when<span pulumi-lang-nodejs=" ruleTarget " pulumi-lang-dotnet=" RuleTarget " pulumi-lang-go=" ruleTarget " pulumi-lang-python=" rule_target " pulumi-lang-yaml=" ruleTarget " pulumi-lang-java=" ruleTarget "> rule_target </span>is json, a CSS selector when<span pulumi-lang-nodejs=" ruleTarget " pulumi-lang-dotnet=" RuleTarget " pulumi-lang-go=" ruleTarget " pulumi-lang-python=" rule_target " pulumi-lang-yaml=" ruleTarget " pulumi-lang-java=" ruleTarget "> rule_target </span>is XML, name of the header for headers or a parameter name for query parameters
     */
    targetField: string;
}

export interface IncomingWebhookCauseField {
    /**
     * How should we extract content the field. Should be a valid Regex when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is match_regex.
     */
    content: string;
    /**
     * When should we start extracting content for the field. Should be present when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is either<span pulumi-lang-nodejs=" matchBetween " pulumi-lang-dotnet=" MatchBetween " pulumi-lang-go=" matchBetween " pulumi-lang-python=" match_between " pulumi-lang-yaml=" matchBetween " pulumi-lang-java=" matchBetween "> match_between </span>or match_after.
     */
    contentAfter: string;
    /**
     * When should we stop extracting content for the field. Should be present when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is either<span pulumi-lang-nodejs=" matchBetween " pulumi-lang-dotnet=" MatchBetween " pulumi-lang-go=" matchBetween " pulumi-lang-python=" match_between " pulumi-lang-yaml=" matchBetween " pulumi-lang-java=" matchBetween "> match_between </span>or match_before.
     */
    contentBefore: string;
    /**
     * The target of the field. Can be any of the following: from_email, subject, or body for email integrations or query_string, header, body, json and xml for incoming webhooks.
     */
    fieldTarget: string;
    /**
     * The match type of the field. Can be any of the following: match_before, match_after, match_between, match_regex, or match_everything.
     */
    matchType: string;
    /**
     * The name of the field.
     */
    name: string;
    /**
     * A special type of the field. Can be<span pulumi-lang-nodejs=" alertId " pulumi-lang-dotnet=" AlertId " pulumi-lang-go=" alertId " pulumi-lang-python=" alert_id " pulumi-lang-yaml=" alertId " pulumi-lang-java=" alertId "> alert_id </span>or cause or otherwise null for a custom field.
     */
    specialType: string;
    /**
     * The target field within the content of the field_target. Should be a JSON key when<span pulumi-lang-nodejs=" fieldTarget " pulumi-lang-dotnet=" FieldTarget " pulumi-lang-go=" fieldTarget " pulumi-lang-python=" field_target " pulumi-lang-yaml=" fieldTarget " pulumi-lang-java=" fieldTarget "> field_target </span>is json, a CSS selector when<span pulumi-lang-nodejs=" fieldTarget " pulumi-lang-dotnet=" FieldTarget " pulumi-lang-go=" fieldTarget " pulumi-lang-python=" field_target " pulumi-lang-yaml=" fieldTarget " pulumi-lang-java=" fieldTarget "> field_target </span>is XML, name of the header for headers or a parameter name for query parameters
     */
    targetField: string;
}

export interface IncomingWebhookOtherAcknowledgedField {
    /**
     * How should we extract content the field. Should be a valid Regex when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is match_regex.
     */
    content: string;
    /**
     * When should we start extracting content for the field. Should be present when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is either<span pulumi-lang-nodejs=" matchBetween " pulumi-lang-dotnet=" MatchBetween " pulumi-lang-go=" matchBetween " pulumi-lang-python=" match_between " pulumi-lang-yaml=" matchBetween " pulumi-lang-java=" matchBetween "> match_between </span>or match_after.
     */
    contentAfter: string;
    /**
     * When should we stop extracting content for the field. Should be present when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is either<span pulumi-lang-nodejs=" matchBetween " pulumi-lang-dotnet=" MatchBetween " pulumi-lang-go=" matchBetween " pulumi-lang-python=" match_between " pulumi-lang-yaml=" matchBetween " pulumi-lang-java=" matchBetween "> match_between </span>or match_before.
     */
    contentBefore: string;
    /**
     * The target of the field. Can be any of the following: from_email, subject, or body for email integrations or query_string, header, body, json and xml for incoming webhooks.
     */
    fieldTarget: string;
    /**
     * The match type of the field. Can be any of the following: match_before, match_after, match_between, match_regex, or match_everything.
     */
    matchType: string;
    /**
     * The name of the field.
     */
    name: string;
    /**
     * A special type of the field. Can be<span pulumi-lang-nodejs=" alertId " pulumi-lang-dotnet=" AlertId " pulumi-lang-go=" alertId " pulumi-lang-python=" alert_id " pulumi-lang-yaml=" alertId " pulumi-lang-java=" alertId "> alert_id </span>or cause or otherwise null for a custom field.
     */
    specialType: string;
    /**
     * The target field within the content of the field_target. Should be a JSON key when<span pulumi-lang-nodejs=" fieldTarget " pulumi-lang-dotnet=" FieldTarget " pulumi-lang-go=" fieldTarget " pulumi-lang-python=" field_target " pulumi-lang-yaml=" fieldTarget " pulumi-lang-java=" fieldTarget "> field_target </span>is json, a CSS selector when<span pulumi-lang-nodejs=" fieldTarget " pulumi-lang-dotnet=" FieldTarget " pulumi-lang-go=" fieldTarget " pulumi-lang-python=" field_target " pulumi-lang-yaml=" fieldTarget " pulumi-lang-java=" fieldTarget "> field_target </span>is XML, name of the header for headers or a parameter name for query parameters
     */
    targetField: string;
}

export interface IncomingWebhookOtherResolvedField {
    /**
     * How should we extract content the field. Should be a valid Regex when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is match_regex.
     */
    content: string;
    /**
     * When should we start extracting content for the field. Should be present when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is either<span pulumi-lang-nodejs=" matchBetween " pulumi-lang-dotnet=" MatchBetween " pulumi-lang-go=" matchBetween " pulumi-lang-python=" match_between " pulumi-lang-yaml=" matchBetween " pulumi-lang-java=" matchBetween "> match_between </span>or match_after.
     */
    contentAfter: string;
    /**
     * When should we stop extracting content for the field. Should be present when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is either<span pulumi-lang-nodejs=" matchBetween " pulumi-lang-dotnet=" MatchBetween " pulumi-lang-go=" matchBetween " pulumi-lang-python=" match_between " pulumi-lang-yaml=" matchBetween " pulumi-lang-java=" matchBetween "> match_between </span>or match_before.
     */
    contentBefore: string;
    /**
     * The target of the field. Can be any of the following: from_email, subject, or body for email integrations or query_string, header, body, json and xml for incoming webhooks.
     */
    fieldTarget: string;
    /**
     * The match type of the field. Can be any of the following: match_before, match_after, match_between, match_regex, or match_everything.
     */
    matchType: string;
    /**
     * The name of the field.
     */
    name: string;
    /**
     * A special type of the field. Can be<span pulumi-lang-nodejs=" alertId " pulumi-lang-dotnet=" AlertId " pulumi-lang-go=" alertId " pulumi-lang-python=" alert_id " pulumi-lang-yaml=" alertId " pulumi-lang-java=" alertId "> alert_id </span>or cause or otherwise null for a custom field.
     */
    specialType: string;
    /**
     * The target field within the content of the field_target. Should be a JSON key when<span pulumi-lang-nodejs=" fieldTarget " pulumi-lang-dotnet=" FieldTarget " pulumi-lang-go=" fieldTarget " pulumi-lang-python=" field_target " pulumi-lang-yaml=" fieldTarget " pulumi-lang-java=" fieldTarget "> field_target </span>is json, a CSS selector when<span pulumi-lang-nodejs=" fieldTarget " pulumi-lang-dotnet=" FieldTarget " pulumi-lang-go=" fieldTarget " pulumi-lang-python=" field_target " pulumi-lang-yaml=" fieldTarget " pulumi-lang-java=" fieldTarget "> field_target </span>is XML, name of the header for headers or a parameter name for query parameters
     */
    targetField: string;
}

export interface IncomingWebhookOtherStartedField {
    /**
     * How should we extract content the field. Should be a valid Regex when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is match_regex.
     */
    content: string;
    /**
     * When should we start extracting content for the field. Should be present when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is either<span pulumi-lang-nodejs=" matchBetween " pulumi-lang-dotnet=" MatchBetween " pulumi-lang-go=" matchBetween " pulumi-lang-python=" match_between " pulumi-lang-yaml=" matchBetween " pulumi-lang-java=" matchBetween "> match_between </span>or match_after.
     */
    contentAfter: string;
    /**
     * When should we stop extracting content for the field. Should be present when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is either<span pulumi-lang-nodejs=" matchBetween " pulumi-lang-dotnet=" MatchBetween " pulumi-lang-go=" matchBetween " pulumi-lang-python=" match_between " pulumi-lang-yaml=" matchBetween " pulumi-lang-java=" matchBetween "> match_between </span>or match_before.
     */
    contentBefore: string;
    /**
     * The target of the field. Can be any of the following: from_email, subject, or body for email integrations or query_string, header, body, json and xml for incoming webhooks.
     */
    fieldTarget: string;
    /**
     * The match type of the field. Can be any of the following: match_before, match_after, match_between, match_regex, or match_everything.
     */
    matchType: string;
    /**
     * The name of the field.
     */
    name: string;
    /**
     * A special type of the field. Can be<span pulumi-lang-nodejs=" alertId " pulumi-lang-dotnet=" AlertId " pulumi-lang-go=" alertId " pulumi-lang-python=" alert_id " pulumi-lang-yaml=" alertId " pulumi-lang-java=" alertId "> alert_id </span>or cause or otherwise null for a custom field.
     */
    specialType: string;
    /**
     * The target field within the content of the field_target. Should be a JSON key when<span pulumi-lang-nodejs=" fieldTarget " pulumi-lang-dotnet=" FieldTarget " pulumi-lang-go=" fieldTarget " pulumi-lang-python=" field_target " pulumi-lang-yaml=" fieldTarget " pulumi-lang-java=" fieldTarget "> field_target </span>is json, a CSS selector when<span pulumi-lang-nodejs=" fieldTarget " pulumi-lang-dotnet=" FieldTarget " pulumi-lang-go=" fieldTarget " pulumi-lang-python=" field_target " pulumi-lang-yaml=" fieldTarget " pulumi-lang-java=" fieldTarget "> field_target </span>is XML, name of the header for headers or a parameter name for query parameters
     */
    targetField: string;
}

export interface IncomingWebhookResolvedAlertIdField {
    /**
     * How should we extract content the field. Should be a valid Regex when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is match_regex.
     */
    content: string;
    /**
     * When should we start extracting content for the field. Should be present when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is either<span pulumi-lang-nodejs=" matchBetween " pulumi-lang-dotnet=" MatchBetween " pulumi-lang-go=" matchBetween " pulumi-lang-python=" match_between " pulumi-lang-yaml=" matchBetween " pulumi-lang-java=" matchBetween "> match_between </span>or match_after.
     */
    contentAfter: string;
    /**
     * When should we stop extracting content for the field. Should be present when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is either<span pulumi-lang-nodejs=" matchBetween " pulumi-lang-dotnet=" MatchBetween " pulumi-lang-go=" matchBetween " pulumi-lang-python=" match_between " pulumi-lang-yaml=" matchBetween " pulumi-lang-java=" matchBetween "> match_between </span>or match_before.
     */
    contentBefore: string;
    /**
     * The target of the field. Can be any of the following: from_email, subject, or body for email integrations or query_string, header, body, json and xml for incoming webhooks.
     */
    fieldTarget: string;
    /**
     * The match type of the field. Can be any of the following: match_before, match_after, match_between, match_regex, or match_everything.
     */
    matchType: string;
    /**
     * The name of the field.
     */
    name: string;
    /**
     * A special type of the field. Can be<span pulumi-lang-nodejs=" alertId " pulumi-lang-dotnet=" AlertId " pulumi-lang-go=" alertId " pulumi-lang-python=" alert_id " pulumi-lang-yaml=" alertId " pulumi-lang-java=" alertId "> alert_id </span>or cause or otherwise null for a custom field.
     */
    specialType: string;
    /**
     * The target field within the content of the field_target. Should be a JSON key when<span pulumi-lang-nodejs=" fieldTarget " pulumi-lang-dotnet=" FieldTarget " pulumi-lang-go=" fieldTarget " pulumi-lang-python=" field_target " pulumi-lang-yaml=" fieldTarget " pulumi-lang-java=" fieldTarget "> field_target </span>is json, a CSS selector when<span pulumi-lang-nodejs=" fieldTarget " pulumi-lang-dotnet=" FieldTarget " pulumi-lang-go=" fieldTarget " pulumi-lang-python=" field_target " pulumi-lang-yaml=" fieldTarget " pulumi-lang-java=" fieldTarget "> field_target </span>is XML, name of the header for headers or a parameter name for query parameters
     */
    targetField: string;
}

export interface IncomingWebhookResolvedRule {
    /**
     * The content we should match to satisfy the rule. Should be a valid Regex when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is match_regex.
     */
    content: string;
    /**
     * The type of the rule. Can be any of the following: contains, contains_not, matches_regex, matches_regex_not, equals, or equals_not.
     */
    matchType: string;
    /**
     * The target of the rule. Can be any of the following: from_email, subject, or body for email integrations or query_string, header, body, json and xml for incoming webhooks.
     */
    ruleTarget: string;
    /**
     * The target field within the content of the rule_target. Should be a JSON key when<span pulumi-lang-nodejs=" ruleTarget " pulumi-lang-dotnet=" RuleTarget " pulumi-lang-go=" ruleTarget " pulumi-lang-python=" rule_target " pulumi-lang-yaml=" ruleTarget " pulumi-lang-java=" ruleTarget "> rule_target </span>is json, a CSS selector when<span pulumi-lang-nodejs=" ruleTarget " pulumi-lang-dotnet=" RuleTarget " pulumi-lang-go=" ruleTarget " pulumi-lang-python=" rule_target " pulumi-lang-yaml=" ruleTarget " pulumi-lang-java=" ruleTarget "> rule_target </span>is XML, name of the header for headers or a parameter name for query parameters
     */
    targetField: string;
}

export interface IncomingWebhookStartedAlertIdField {
    /**
     * How should we extract content the field. Should be a valid Regex when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is match_regex.
     */
    content: string;
    /**
     * When should we start extracting content for the field. Should be present when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is either<span pulumi-lang-nodejs=" matchBetween " pulumi-lang-dotnet=" MatchBetween " pulumi-lang-go=" matchBetween " pulumi-lang-python=" match_between " pulumi-lang-yaml=" matchBetween " pulumi-lang-java=" matchBetween "> match_between </span>or match_after.
     */
    contentAfter: string;
    /**
     * When should we stop extracting content for the field. Should be present when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is either<span pulumi-lang-nodejs=" matchBetween " pulumi-lang-dotnet=" MatchBetween " pulumi-lang-go=" matchBetween " pulumi-lang-python=" match_between " pulumi-lang-yaml=" matchBetween " pulumi-lang-java=" matchBetween "> match_between </span>or match_before.
     */
    contentBefore: string;
    /**
     * The target of the field. Can be any of the following: from_email, subject, or body for email integrations or query_string, header, body, json and xml for incoming webhooks.
     */
    fieldTarget: string;
    /**
     * The match type of the field. Can be any of the following: match_before, match_after, match_between, match_regex, or match_everything.
     */
    matchType: string;
    /**
     * The name of the field.
     */
    name: string;
    /**
     * A special type of the field. Can be<span pulumi-lang-nodejs=" alertId " pulumi-lang-dotnet=" AlertId " pulumi-lang-go=" alertId " pulumi-lang-python=" alert_id " pulumi-lang-yaml=" alertId " pulumi-lang-java=" alertId "> alert_id </span>or cause or otherwise null for a custom field.
     */
    specialType: string;
    /**
     * The target field within the content of the field_target. Should be a JSON key when<span pulumi-lang-nodejs=" fieldTarget " pulumi-lang-dotnet=" FieldTarget " pulumi-lang-go=" fieldTarget " pulumi-lang-python=" field_target " pulumi-lang-yaml=" fieldTarget " pulumi-lang-java=" fieldTarget "> field_target </span>is json, a CSS selector when<span pulumi-lang-nodejs=" fieldTarget " pulumi-lang-dotnet=" FieldTarget " pulumi-lang-go=" fieldTarget " pulumi-lang-python=" field_target " pulumi-lang-yaml=" fieldTarget " pulumi-lang-java=" fieldTarget "> field_target </span>is XML, name of the header for headers or a parameter name for query parameters
     */
    targetField: string;
}

export interface IncomingWebhookStartedRule {
    /**
     * The content we should match to satisfy the rule. Should be a valid Regex when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is match_regex.
     */
    content: string;
    /**
     * The type of the rule. Can be any of the following: contains, contains_not, matches_regex, matches_regex_not, equals, or equals_not.
     */
    matchType: string;
    /**
     * The target of the rule. Can be any of the following: from_email, subject, or body for email integrations or query_string, header, body, json and xml for incoming webhooks.
     */
    ruleTarget: string;
    /**
     * The target field within the content of the rule_target. Should be a JSON key when<span pulumi-lang-nodejs=" ruleTarget " pulumi-lang-dotnet=" RuleTarget " pulumi-lang-go=" ruleTarget " pulumi-lang-python=" rule_target " pulumi-lang-yaml=" ruleTarget " pulumi-lang-java=" ruleTarget "> rule_target </span>is json, a CSS selector when<span pulumi-lang-nodejs=" ruleTarget " pulumi-lang-dotnet=" RuleTarget " pulumi-lang-go=" ruleTarget " pulumi-lang-python=" rule_target " pulumi-lang-yaml=" ruleTarget " pulumi-lang-java=" ruleTarget "> rule_target </span>is XML, name of the header for headers or a parameter name for query parameters
     */
    targetField: string;
}

export interface IncomingWebhookTitleField {
    /**
     * How should we extract content the field. Should be a valid Regex when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is match_regex.
     */
    content: string;
    /**
     * When should we start extracting content for the field. Should be present when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is either<span pulumi-lang-nodejs=" matchBetween " pulumi-lang-dotnet=" MatchBetween " pulumi-lang-go=" matchBetween " pulumi-lang-python=" match_between " pulumi-lang-yaml=" matchBetween " pulumi-lang-java=" matchBetween "> match_between </span>or match_after.
     */
    contentAfter: string;
    /**
     * When should we stop extracting content for the field. Should be present when<span pulumi-lang-nodejs=" matchType " pulumi-lang-dotnet=" MatchType " pulumi-lang-go=" matchType " pulumi-lang-python=" match_type " pulumi-lang-yaml=" matchType " pulumi-lang-java=" matchType "> match_type </span>is either<span pulumi-lang-nodejs=" matchBetween " pulumi-lang-dotnet=" MatchBetween " pulumi-lang-go=" matchBetween " pulumi-lang-python=" match_between " pulumi-lang-yaml=" matchBetween " pulumi-lang-java=" matchBetween "> match_between </span>or match_before.
     */
    contentBefore: string;
    /**
     * The target of the field. Can be any of the following: from_email, subject, or body for email integrations or query_string, header, body, json and xml for incoming webhooks.
     */
    fieldTarget: string;
    /**
     * The match type of the field. Can be any of the following: match_before, match_after, match_between, match_regex, or match_everything.
     */
    matchType: string;
    /**
     * The name of the field.
     */
    name: string;
    /**
     * A special type of the field. Can be<span pulumi-lang-nodejs=" alertId " pulumi-lang-dotnet=" AlertId " pulumi-lang-go=" alertId " pulumi-lang-python=" alert_id " pulumi-lang-yaml=" alertId " pulumi-lang-java=" alertId "> alert_id </span>or cause or otherwise null for a custom field.
     */
    specialType: string;
    /**
     * The target field within the content of the field_target. Should be a JSON key when<span pulumi-lang-nodejs=" fieldTarget " pulumi-lang-dotnet=" FieldTarget " pulumi-lang-go=" fieldTarget " pulumi-lang-python=" field_target " pulumi-lang-yaml=" fieldTarget " pulumi-lang-java=" fieldTarget "> field_target </span>is json, a CSS selector when<span pulumi-lang-nodejs=" fieldTarget " pulumi-lang-dotnet=" FieldTarget " pulumi-lang-go=" fieldTarget " pulumi-lang-python=" field_target " pulumi-lang-yaml=" fieldTarget " pulumi-lang-java=" fieldTarget "> field_target </span>is XML, name of the header for headers or a parameter name for query parameters
     */
    targetField: string;
}

export interface MetadataMetadataValue {
    /**
     * Email of the referenced user when type is `User`.
     */
    email?: string;
    /**
     * ID of the referenced item when type is different than `String`.
     */
    itemId?: string;
    /**
     * Name of the referenced item when type is different than `String`.
     */
    name?: string;
    /**
     * Value types can be grouped into 2 main categories:
     *   - **Scalar**: `String`
     *   - **Reference**: `User`, `Team`, `Policy`, `Schedule`, `SlackIntegration`, `LinearIntegration`, `JiraIntegration`, `MicrosoftTeamsWebhook`, `ZapierWebhook`, `NativeWebhook`, `PagerDutyWebhook`
     *   
     *   The value of a **Scalar** type is defined using the value field.
     *   
     *   The value of a **Reference** type is defined using one of the following fields:
     *   - <span pulumi-lang-nodejs="`itemId`" pulumi-lang-dotnet="`ItemId`" pulumi-lang-go="`itemId`" pulumi-lang-python="`item_id`" pulumi-lang-yaml="`itemId`" pulumi-lang-java="`itemId`">`item_id`</span> - great choice when you know the ID of the target item.
     *   - <span pulumi-lang-nodejs="`email`" pulumi-lang-dotnet="`Email`" pulumi-lang-go="`email`" pulumi-lang-python="`email`" pulumi-lang-yaml="`email`" pulumi-lang-java="`email`">`email`</span> - your go-to choice when you're referencing users.
     *   - <span pulumi-lang-nodejs="`name`" pulumi-lang-dotnet="`Name`" pulumi-lang-go="`name`" pulumi-lang-python="`name`" pulumi-lang-yaml="`name`" pulumi-lang-java="`name`">`name`</span> - can be used to reference other items like teams, policies, etc.
     *   
     *   **The reference types require the presence of at least one of the three fields: <span pulumi-lang-nodejs="`itemId`" pulumi-lang-dotnet="`ItemId`" pulumi-lang-go="`itemId`" pulumi-lang-python="`item_id`" pulumi-lang-yaml="`itemId`" pulumi-lang-java="`itemId`">`item_id`</span>, <span pulumi-lang-nodejs="`name`" pulumi-lang-dotnet="`Name`" pulumi-lang-go="`name`" pulumi-lang-python="`name`" pulumi-lang-yaml="`name`" pulumi-lang-java="`name`">`name`</span>, <span pulumi-lang-nodejs="`email`" pulumi-lang-dotnet="`Email`" pulumi-lang-go="`email`" pulumi-lang-python="`email`" pulumi-lang-yaml="`email`" pulumi-lang-java="`email`">`email`</span>.**
     */
    type?: string;
    /**
     * Value when type is String.
     */
    value?: string;
}

export interface OnCallCalendarOnCallRotation {
    /**
     * End time of the rotation in RFC 3339 format (e.g. `2026-01-01T00:00:00Z`)
     */
    endRotationsAt: string;
    /**
     * The interval unit for rotation_length. Must be one of: <span pulumi-lang-nodejs="`hour`" pulumi-lang-dotnet="`Hour`" pulumi-lang-go="`hour`" pulumi-lang-python="`hour`" pulumi-lang-yaml="`hour`" pulumi-lang-java="`hour`">`hour`</span>, <span pulumi-lang-nodejs="`day`" pulumi-lang-dotnet="`Day`" pulumi-lang-go="`day`" pulumi-lang-python="`day`" pulumi-lang-yaml="`day`" pulumi-lang-java="`day`">`day`</span>, <span pulumi-lang-nodejs="`week`" pulumi-lang-dotnet="`Week`" pulumi-lang-go="`week`" pulumi-lang-python="`week`" pulumi-lang-yaml="`week`" pulumi-lang-java="`week`">`week`</span>.
     */
    rotationInterval: string;
    /**
     * The length of each rotation shift. See <span pulumi-lang-nodejs="`rotationInterval`" pulumi-lang-dotnet="`RotationInterval`" pulumi-lang-go="`rotationInterval`" pulumi-lang-python="`rotation_interval`" pulumi-lang-yaml="`rotationInterval`" pulumi-lang-java="`rotationInterval`">`rotation_interval`</span> for units.
     */
    rotationLength: number;
    /**
     * Start time of the rotation in RFC 3339 format (e.g. `2026-01-01T00:00:00Z`)
     */
    startRotationsAt: string;
    /**
     * List of email addresses for users participating in the rotation.
     */
    users: string[];
}

export interface OnCallCalendarOnCallUser {
    email: string;
    firstName: string;
    id: string;
    lastName: string;
    phoneNumbers: string[];
}

export interface OutgoingWebhookCustomWebhookTemplateAttributes {
    /**
     * The password to use for basic authentication.
     */
    authPassword?: string;
    /**
     * The username to use for basic authentication.
     */
    authUsername?: string;
    /**
     * The body of the webhook request.
     */
    bodyTemplate?: string;
    /**
     * The headers to include in the webhook request.
     */
    headersTemplates?: outputs.OutgoingWebhookCustomWebhookTemplateAttributesHeadersTemplate[];
    /**
     * The HTTP method to use when sending the webhook. Possible values: <span pulumi-lang-nodejs="`get`" pulumi-lang-dotnet="`Get`" pulumi-lang-go="`get`" pulumi-lang-python="`get`" pulumi-lang-yaml="`get`" pulumi-lang-java="`get`">`get`</span>, <span pulumi-lang-nodejs="`post`" pulumi-lang-dotnet="`Post`" pulumi-lang-go="`post`" pulumi-lang-python="`post`" pulumi-lang-yaml="`post`" pulumi-lang-java="`post`">`post`</span>, <span pulumi-lang-nodejs="`put`" pulumi-lang-dotnet="`Put`" pulumi-lang-go="`put`" pulumi-lang-python="`put`" pulumi-lang-yaml="`put`" pulumi-lang-java="`put`">`put`</span>, <span pulumi-lang-nodejs="`patch`" pulumi-lang-dotnet="`Patch`" pulumi-lang-go="`patch`" pulumi-lang-python="`patch`" pulumi-lang-yaml="`patch`" pulumi-lang-java="`patch`">`patch`</span> and <span pulumi-lang-nodejs="`head`" pulumi-lang-dotnet="`Head`" pulumi-lang-go="`head`" pulumi-lang-python="`head`" pulumi-lang-yaml="`head`" pulumi-lang-java="`head`">`head`</span>.
     */
    httpMethod?: string;
    id: string;
}

export interface OutgoingWebhookCustomWebhookTemplateAttributesHeadersTemplate {
    name: string;
    value: string;
}

export interface PolicyStep {
    /**
     * Post instructions as a comment into the incident timeline. You can use Markdown, reference metadata as `{server_region}`, and interactive checkboxes like `- [ ] Step 1`. Used when step type is instructions.
     */
    comment?: string;
    /**
     * An array of days during which the branching rule will be executed. Valid values are ["mon", "tue", "wed", "thu", "fri", "sat", "sun"]. Used when step type is branching.
     */
    days?: string[];
    /**
     * A metadata field key to check. Used when step type is metadata_branching.
     */
    metadataKey?: string;
    /**
     * An array of typed metadata values which will cause the branching rule to be executed. Used when step type is metadata_branching.
     */
    metadataValue?: outputs.PolicyStepMetadataValue[];
    /**
     * An array of metadata String values which will cause the branching rule to be executed. Used when step type is metadata_branching.
     *
     * @deprecated Deprecated
     */
    metadataValues?: string[];
    /**
     * A policy to executed if the branching rule matches the time of an incident. Used when step type is<span pulumi-lang-nodejs=" timeBranching " pulumi-lang-dotnet=" TimeBranching " pulumi-lang-go=" timeBranching " pulumi-lang-python=" time_branching " pulumi-lang-yaml=" timeBranching " pulumi-lang-java=" timeBranching "> time_branching </span>or metadata_branching.
     */
    policyId?: number;
    /**
     * A metadata key from which to extract the policy to executed if the branching rule matches the time of an incident. Used when step type is<span pulumi-lang-nodejs=" timeBranching " pulumi-lang-dotnet=" TimeBranching " pulumi-lang-go=" timeBranching " pulumi-lang-python=" time_branching " pulumi-lang-yaml=" timeBranching " pulumi-lang-java=" timeBranching "> time_branching </span>or metadata_branching.
     */
    policyMetadataKey?: string;
    /**
     * Whether we should followup periodically unless all checkboxes are checked. Used when step type is instructions.
     */
    reminderEnabled: boolean;
    /**
     * Time interval in hours we should use for periodical follow-ups. Used when step type is instructions.
     */
    reminderIntervalHours: number;
    /**
     * An array of escalation policy steps members. Used when step type is escalation.
     */
    stepMembers?: outputs.PolicyStepStepMember[];
    /**
     * A time from which the branching rule will be executed. Use HH:MM format. Used when step type is time_branching.
     */
    timeFrom?: string;
    /**
     * A time at which the branching rule will step being executed. Use HH:MM format. Used when step type is time_branching.
     */
    timeTo?: string;
    /**
     * What timezone to use when evaluating time based branching rules. Used when step type is time_branching. The accepted values can be found in the Rails TimeZone documentation. https://api.rubyonrails.org/classes/ActiveSupport/TimeZone.html
     */
    timezone?: string;
    /**
     * The type of the step. Can be either escalation, time_branching, metadata_branching, or instructions.
     */
    type: string;
    /**
     * Which severity to use for this step. Used when step type is escalation.
     */
    urgencyId?: number;
    /**
     * How long to wait in seconds before executing this step since previous step. Omit if<span pulumi-lang-nodejs=" waitUntilTime " pulumi-lang-dotnet=" WaitUntilTime " pulumi-lang-go=" waitUntilTime " pulumi-lang-python=" wait_until_time " pulumi-lang-yaml=" waitUntilTime " pulumi-lang-java=" waitUntilTime "> wait_until_time </span>is set.
     */
    waitBefore?: number;
    /**
     * Execute this step at the specified time. Use HH:MM format. Omit if<span pulumi-lang-nodejs=" waitBefore " pulumi-lang-dotnet=" WaitBefore " pulumi-lang-go=" waitBefore " pulumi-lang-python=" wait_before " pulumi-lang-yaml=" waitBefore " pulumi-lang-java=" waitBefore "> wait_before </span>is set.
     */
    waitUntilTime?: string;
    /**
     * Timezone to use when interpreting wait_until_time. Omit if<span pulumi-lang-nodejs=" waitBefore " pulumi-lang-dotnet=" WaitBefore " pulumi-lang-go=" waitBefore " pulumi-lang-python=" wait_before " pulumi-lang-yaml=" waitBefore " pulumi-lang-java=" waitBefore "> wait_before </span>is set.
     */
    waitUntilTimezone?: string;
}

export interface PolicyStepMetadataValue {
    /**
     * Email of the referenced user when type is `User`.
     */
    email?: string;
    /**
     * ID of the referenced item when type is different than `String`.
     */
    itemId?: string;
    /**
     * Name of the referenced item when type is different than `String`.
     */
    name?: string;
    /**
     * Value types can be grouped into 2 main categories:
     *   - **Scalar**: `String`
     *   - **Reference**: `User`, `Team`, `Policy`, `Schedule`, `SlackIntegration`, `LinearIntegration`, `JiraIntegration`, `MicrosoftTeamsWebhook`, `ZapierWebhook`, `NativeWebhook`, `PagerDutyWebhook`
     *   
     *   The value of a **Scalar** type is defined using the value field.
     *   
     *   The value of a **Reference** type is defined using one of the following fields:
     *   - <span pulumi-lang-nodejs="`itemId`" pulumi-lang-dotnet="`ItemId`" pulumi-lang-go="`itemId`" pulumi-lang-python="`item_id`" pulumi-lang-yaml="`itemId`" pulumi-lang-java="`itemId`">`item_id`</span> - great choice when you know the ID of the target item.
     *   - <span pulumi-lang-nodejs="`email`" pulumi-lang-dotnet="`Email`" pulumi-lang-go="`email`" pulumi-lang-python="`email`" pulumi-lang-yaml="`email`" pulumi-lang-java="`email`">`email`</span> - your go-to choice when you're referencing users.
     *   - <span pulumi-lang-nodejs="`name`" pulumi-lang-dotnet="`Name`" pulumi-lang-go="`name`" pulumi-lang-python="`name`" pulumi-lang-yaml="`name`" pulumi-lang-java="`name`">`name`</span> - can be used to reference other items like teams, policies, etc.
     *   
     *   **The reference types require the presence of at least one of the three fields: <span pulumi-lang-nodejs="`itemId`" pulumi-lang-dotnet="`ItemId`" pulumi-lang-go="`itemId`" pulumi-lang-python="`item_id`" pulumi-lang-yaml="`itemId`" pulumi-lang-java="`itemId`">`item_id`</span>, <span pulumi-lang-nodejs="`name`" pulumi-lang-dotnet="`Name`" pulumi-lang-go="`name`" pulumi-lang-python="`name`" pulumi-lang-yaml="`name`" pulumi-lang-java="`name`">`name`</span>, <span pulumi-lang-nodejs="`email`" pulumi-lang-dotnet="`Email`" pulumi-lang-go="`email`" pulumi-lang-python="`email`" pulumi-lang-yaml="`email`" pulumi-lang-java="`email`">`email`</span>.**
     */
    type?: string;
    /**
     * Value when type is String.
     */
    value?: string;
}

export interface PolicyStepStepMember {
    /**
     * The ID of the resource to notify during an incident. Required for user, webhook, slack_integration, microsoft_teams_integration,<span pulumi-lang-nodejs=" zapierWebhook " pulumi-lang-dotnet=" ZapierWebhook " pulumi-lang-go=" zapierWebhook " pulumi-lang-python=" zapier_webhook " pulumi-lang-yaml=" zapierWebhook " pulumi-lang-java=" zapierWebhook "> zapier_webhook </span>and<span pulumi-lang-nodejs=" pagerdutyIntegration " pulumi-lang-dotnet=" PagerdutyIntegration " pulumi-lang-go=" pagerdutyIntegration " pulumi-lang-python=" pagerduty_integration " pulumi-lang-yaml=" pagerdutyIntegration " pulumi-lang-java=" pagerdutyIntegration "> pagerduty_integration </span>member types. This is e.g. the ID of the user to notify when member type is user, or on-call calendar ID of when member type is current_on_call.
     */
    id?: number;
    /**
     * The metadata key to use to retrieve the escalation target from the incident's metadata. Required when type is incident_metadata.
     */
    metadataKey?: string;
    /**
     * The ID of the team to notify when member team is entire_team. When left empty, the default team for the incident is used. This field is deprecated, use id instead.
     *
     * @deprecated Deprecated
     */
    teamId?: number;
    /**
     * Type type of the member to notify during an incident. Can be one of current_on_call, entire_team, all_slack_integrations, all_microsoft_teams_integrations, all_zapier_integrations, all_webhook_integrations, all_splunk_on_call_integrations, incident_metadata, user, webhook, slack_integration, microsoft_teams_integration,<span pulumi-lang-nodejs=" zapierWebhook " pulumi-lang-dotnet=" ZapierWebhook " pulumi-lang-go=" zapierWebhook " pulumi-lang-python=" zapier_webhook " pulumi-lang-yaml=" zapierWebhook " pulumi-lang-java=" zapierWebhook "> zapier_webhook </span>or pagerduty_integration.
     */
    type: string;
}

export interface StatusPageNavigationLink {
    /**
     * Href of the link. Use full URL for external links. Use `/`, `/maintenance` and `/incidents` for built-in links.
     */
    href: string;
    /**
     * Label of the link.
     */
    text: string;
}

export interface StatusPageResourceStatusHistory {
    day: string;
    downtimeDuration: number;
    maintenanceDuration: number;
    status: string;
}

